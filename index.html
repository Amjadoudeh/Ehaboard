<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ehab Board</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* CSS Variables for easier theming and dark mode */
        :root {
            /* Google-inspired Light Mode Palette */
            --bg-light: #F9FAFB; /* Very light gray, almost white */
            --bg-card-light: #FFFFFF; /* Pure white for cards/modals */
            --bg-column-light: #F3F4F6; /* Slightly warmer light gray for columns */
            --text-primary-light: #1F2937; /* Dark charcoal */
            --text-secondary-light: #6B7280; /* Muted gray */
            --border-light: #E5E7EB; /* Light gray border */
            --shadow-light: rgba(0, 0, 0, 0.08); /* Softer shadow */
            --modal-bg-light: #FFFFFF;
            --modal-shadow-light: rgba(0, 0, 0, 0.15);
            --drag-over-color-light: #E8F0FE; /* Very light Google Blue */
            --unread-notification-bg-light: #E8F0FE; /* Very light Google Blue for unread */
            --progress-bar-bg-light: #E0E0E0; /* Light gray for progress bar track */

            /* Google-inspired Button Colors */
            --button-primary: #4285F4; /* Google Blue */
            --button-primary-hover: #357AE8;
            --button-success: #34A853; /* Google Green */
            --button-success-hover: #2E8B45;
            --button-danger: #EA4335; /* Google Red */
            --button-danger-hover: #D03E2F;
            --button-secondary: #9AA0A6; /* Google Gray */
            --button-secondary-hover: #7F8489;
            --button-purple: #8854C0; /* Softer Purple */
            --button-purple-hover: #7A49B0;
            --button-teal: #00B8D4; /* Vibrant Teal */
            --button-teal-hover: #00A3BF;
        }

        html.dark {
            /* Google-inspired Dark Mode Palette */
            --bg-dark: #202124; /* Dark charcoal */
            --bg-card-dark: #3C4043; /* Darker gray for cards/modals */
            --bg-column-dark: #5F6368; /* Slightly lighter than body for columns */
            --text-primary-dark: #E8EAED; /* Very light gray */
            --text-secondary-dark: #BDC1C6; /* Muted light gray */
            --border-dark: #70757A; /* Darker border */
            --shadow-dark: rgba(0, 0, 0, 0.4); /* Stronger shadow for dark mode */
            --modal-bg-dark: #3C4043;
            --modal-shadow-dark: rgba(0, 0, 0, 0.6);
            --drag-over-color-dark: #3B5B7E; /* Darker blue */
            --unread-notification-bg-dark: #3B5B7E; /* Dark blue for unread */
            --progress-bar-bg-dark: #5F6368; /* Dark gray for progress bar track */

            /* Dark mode buttons use same colors, but might appear slightly different due to background contrast */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-light);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            color: var(--text-primary-light);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        html.dark body {
            background-color: var(--bg-dark);
            color: var(--text-primary-dark);
        }

        #app-container {
            background-color: var(--bg-card-light); /* This will be overridden by board background settings */
            border-radius: 15px;
            box-shadow: 0 10px 30px var(--shadow-light);
            padding: 20px; /* Reduced padding to give more space for board */
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column; /* Changed to column for header above board */
            gap: 20px;
            transition: background-color 0.3s ease, box-shadow 0.3s ease, background-image 0.3s ease;
            min-height: calc(100vh - 40px); /* Ensure it takes up most of the screen height */
        }

        html.dark #app-container {
            background-color: var(--bg-card-dark);
            box-shadow: 0 10px 30px var(--shadow-dark);
        }

        #main-header {
            background-color: var(--bg-card-light);
            border-radius: 12px;
            box-shadow: 0 4px 12px var(--shadow-light);
            padding: 15px 25px;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            border: 1px solid var(--border-light);
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }
        html.dark #main-header {
            background-color: var(--bg-card-dark);
            box-shadow: 0 4px 12px var(--shadow-dark);
            border-color: var(--border-dark);
        }
        @media (min-width: 768px) {
            #main-header {
                flex-direction: row;
                justify-content: space-between;
            }
        }

        #kanban-board-wrapper {
            flex-grow: 1;
            overflow-x: auto; /* Enable horizontal scrolling */
            padding-bottom: 10px; /* Space for scrollbar */
            min-height: 500px; /* Ensure minimum height for board */
        }

        #kanban-board {
            display: flex;
            gap: 16px; /* Space between columns */
            min-height: 100%; /* Make sure board takes full height of wrapper */
            align-items: flex-start; /* Align columns to the top */
            padding: 5px; /* Small padding inside board */
        }

        .kanban-column {
            background-color: var(--bg-column-light);
            border-radius: 12px;
            padding: 15px; /* Slightly less padding */
            min-width: 280px; /* Fixed width for columns */
            max-width: 280px;
            flex-shrink: 0; /* Prevent columns from shrinking */
            display: flex;
            flex-direction: column;
            gap: 10px; /* Less gap between cards */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border-light);
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }

        html.dark .kanban-column {
            background-color: var(--bg-column-dark);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border-dark);
        }

        #add-column-placeholder {
            min-width: 280px;
            max-width: 280px;
            flex-shrink: 0;
            background-color: var(--bg-column-light);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: var(--text-secondary-light);
            font-weight: 600;
            cursor: pointer;
            border: 2px dashed var(--border-light);
            transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
        }
        html.dark #add-column-placeholder {
            background-color: var(--bg-column-dark);
            border-color: var(--border-dark);
            color: var(--text-secondary-dark);
        }
        #add-column-placeholder:hover {
            background-color: var(--bg-column-light); /* Keep same background on hover */
            border-color: var(--button-primary); /* Highlight border */
            color: var(--button-primary);
        }
        html.dark #add-column-placeholder:hover {
            background-color: var(--bg-column-dark);
            border-color: var(--button-primary); /* Highlight border */
            color: var(--button-primary);
        }


        .task-card {
            background-color: var(--bg-card-light);
            border-radius: 10px;
            padding: 12px; /* Slightly less padding */
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* Softer card shadow */
            cursor: grab;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.3s ease, border-color 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-start;
            border: 1px solid var(--border-light);
            word-break: break-word;
            position: relative;
        }

        html.dark .task-card {
            background-color: var(--bg-card-dark);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            border: 1px solid var(--border-dark);
        }

        .task-card:hover {
            transform: translateY(-1px); /* Less dramatic lift */
            box-shadow: 0 2px 8px rgba(0,0,0,0.15); /* Enhanced hover shadow */
        }
        html.dark .task-card:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .task-card.dragging {
            opacity: 0.5;
            border: 2px dashed var(--button-primary);
        }

        .task-card.done .task-text {
            text-decoration: line-through;
            color: var(--text-secondary-light);
        }
        html.dark .task-card.done .task-text {
            color: var(--text-secondary-dark);
        }

        .delete-button {
            background: none;
            border: none;
            color: var(--button-danger);
            cursor: pointer;
            font-size: 1rem; /* Slightly smaller */
            opacity: 0.7;
            transition: opacity 0.2s ease-in-out, color 0.2s ease;
            position: absolute;
            top: 8px; /* Adjusted position */
            right: 8px;
            z-index: 10;
        }

        .delete-button:hover {
            opacity: 1;
            color: var(--button-danger-hover);
        }

        /* Priority Dot - Hidden in main view as per Trello style */
        .priority-dot {
            display: none; /* Hide in main card view */
        }

        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        .input-field {
            padding: 10px 14px; /* Reduced padding */
            border: 1px solid var(--border-light);
            border-radius: 8px;
            font-size: 0.95rem; /* Slightly smaller font */
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.3s ease, color 0.3s ease;
            background-color: var(--bg-card-light);
            color: var(--text-primary-light);
        }
        html.dark .input-field {
            background-color: var(--bg-card-dark);
            border-color: var(--border-dark);
            color: var(--text-primary-dark);
        }

        .input-field:focus {
            outline: none;
            border-color: var(--button-primary);
            box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.25); /* Google Blue shadow */
        }
        html.dark .input-field:focus {
            border-color: var(--button-primary);
            box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.4);
        }

        .action-button {
            padding: 10px 20px; /* Reduced padding */
            background-color: var(--button-primary);
            color: white;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1); /* Softer shadow for buttons */
            font-size: 0.95rem; /* Slightly smaller font */
            display: inline-flex; /* For icon alignment */
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .action-button:hover {
            background-color: var(--button-primary-hover);
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
        }

        .action-button:active {
            transform: translateY(0);
            box-shadow: none;
        }

        /* Specific button colors */
        .action-button.bg-green-500 { background-color: var(--button-success); }
        .action-button.bg-green-500:hover { background-color: var(--button-success-hover); }
        .action-button.bg-red-500 { background-color: var(--button-danger); }
        .action-button.bg-red-500:hover { background-color: var(--button-danger-hover); }
        .action-button.bg-gray-500 { background-color: var(--button-secondary); }
        .action-button.bg-gray-500:hover { background-color: var(--button-secondary-hover); }
        .action-button.bg-purple-500 { background-color: var(--button-purple); }
        .action-button.bg-purple-500:hover { background-color: var(--button-purple-hover); }
        .action-button.bg-teal-500 { background-color: var(--button-teal); }
        .action-button.bg-teal-500:hover { background-color: var(--button-teal-hover); }


        .column-title {
            font-size: 1.2rem; /* Slightly smaller title */
            font-weight: 700;
            color: var(--text-primary-light);
            margin-bottom: 12px; /* Less space */
            text-align: center;
            transition: color 0.3s ease;
        }
        html.dark .column-title {
            color: var(--text-primary-dark);
        }

        #user-info-block {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 0;
            padding: 0;
            border: none;
        }

        #current-user-display-name {
            font-size: 1rem; /* Smaller display name in header */
            font-weight: 600;
            color: var(--text-primary-light);
            transition: color 0.3s ease;
        }
        html.dark #current-user-display-name {
            color: var(--text-primary-dark);
        }

        #current-user-id {
            display: none; /* Hide ID from main header for cleaner look */
        }

        .auth-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 0;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--modal-bg-light);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 12px 30px var(--modal-shadow-light);
            width: 90%;
            max-width: 500px;
            position: relative;
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out, background-color 0.3s ease, box-shadow 0.3s ease;
        }
        html.dark .modal-content {
            background-color: var(--modal-bg-dark);
            box-shadow: 0 12px 30px var(--modal-shadow-dark);
        }

        .modal-overlay.show .modal-content {
            transform: translateY(0);
        }

        .modal-close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 1.4rem;
            color: var(--text-secondary-light);
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .modal-close-button:hover {
            color: var(--text-primary-light);
        }
        html.dark .modal-close-button {
            color: var(--text-secondary-dark);
        }
        html.dark .modal-close-button:hover {
            color: var(--text-primary-dark);
        }

        .google-signin-button {
            background-color: #4285f4; /* Standard Google Blue */
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 3px 8px rgba(66, 133, 244, 0.2);
        }

        .google-signin-button:hover {
            background-color: #357ae8;
            transform: translateY(-1px);
        }

        .google-signin-button:active {
            transform: translateY(0);
            box-shadow: none;
        }

        .google-signin-button img {
            width: 18px;
            height: 18px;
        }

        /* Message Display Styles */
        #message-display {
            padding: 10px 20px;
            font-size: 0.95rem;
            color: white; /* Default text color for messages */
        }
        #message-display.success { background-color: var(--button-success); }
        #message-display.error { background-color: var(--button-danger); }
        #message-display.info { background-color: var(--button-primary); }


        /* Board Selector Styles */
        #board-management-section {
            display: flex;
            flex-direction: row;
            gap: 8px;
            margin-bottom: 0;
            width: auto;
            max-width: none;
            align-items: center;
            justify-content: flex-start;
        }

        #board-selector {
            padding: 8px 12px;
            font-size: 0.9rem;
            width: auto;
            max-width: 200px;
        }

        /* Task Detail Modal Specific Styles */
        #task-detail-modal .modal-content {
            max-width: 700px;
            padding: 20px;
        }

        #task-detail-modal .modal-body {
            padding-right: 10px;
        }

        #task-detail-modal h3 {
            font-size: 1rem;
            margin-top: 15px;
            margin-bottom: 8px;
            color: var(--text-primary-light);
        }
        html.dark #task-detail-modal h3 {
            color: var(--text-primary-dark);
        }

        #task-detail-modal .detail-section {
            padding-top: 10px;
            margin-top: 10px;
        }

        .checklist-item {
            padding: 6px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checklist-item input[type="checkbox"] {
            transform: scale(1.1);
            accent-color: var(--button-primary); /* Style checkbox with primary color */
        }

        .checklist-item .item-text {
            font-size: 0.9rem;
            flex-grow: 1;
            color: var(--text-primary-light);
        }
        html.dark .checklist-item .item-text {
            color: var(--text-primary-dark);
        }
        .checklist-item .item-text.completed {
            text-decoration: line-through;
            color: var(--text-secondary-light);
        }
        html.dark .checklist-item .item-text.completed {
            color: var(--text-secondary-dark);
        }


        .comment-item {
            background-color: var(--bg-column-light); /* Use column background for comments */
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            font-size: 0.85rem;
            position: relative;
            border: 1px solid var(--border-light);
        }
        html.dark .comment-item {
            background-color: var(--bg-column-dark);
            border: 1px solid var(--border-dark);
        }

        .comment-item .comment-author {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary-light);
            margin-bottom: 3px;
        }
        html.dark .comment-item .comment-author {
            color: var(--text-primary-dark);
        }

        .comment-item p {
            color: var(--text-primary-light);
        }
        html.dark .comment-item p {
            color: var(--text-primary-dark);
        }

        .comment-item .comment-timestamp {
            font-size: 0.7rem;
            color: var(--text-secondary-light);
            margin-top: 3px;
            display: block;
        }
        html.dark .comment-item .comment-timestamp {
            color: var(--text-secondary-dark);
        }

        .activity-item {
            font-size: 0.8rem;
            color: var(--text-secondary-light);
            margin-bottom: 6px;
            padding-left: 8px;
            border-left: 2px solid var(--border-light);
        }
        html.dark .activity-item {
            color: var(--text-secondary-dark);
            border-left: 2px solid var(--border-dark);
        }

        .activity-item .activity-timestamp {
            font-size: 0.65rem;
            display: block;
            margin-top: 2px;
            color: var(--text-secondary-light);
        }
        html.dark .activity-item .activity-timestamp {
            color: var(--text-secondary-dark);
        }


        .progress-bar-container {
            height: 8px;
            background-color: var(--progress-bar-bg-light); /* Track color */
            border-radius: 4px; /* Rounded ends for the track */
            overflow: hidden; /* Ensure fill stays within bounds */
            margin-top: 8px;
            margin-bottom: 8px;
        }
        html.dark .progress-bar-container {
            background-color: var(--progress-bar-bg-dark);
        }

        .progress-bar {
            height: 100%;
            background-color: var(--button-primary); /* Fill color */
            border-radius: 4px; /* Rounded ends for the fill */
            transition: width 0.3s ease-in-out;
        }
        html.dark .progress-bar {
            background-color: var(--button-primary); /* Use primary button color for consistency */
        }


        /* Notifications style */
        #notification-center {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1500;
        }

        #notification-button {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background-color: var(--bg-card-light);
            color: var(--text-primary-light);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            cursor: pointer;
            box-shadow: 0 3px 8px var(--shadow-light);
            border: 1px solid var(--border-light);
            position: relative;
            transition: background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
        }
        html.dark #notification-button {
            background-color: var(--bg-card-dark);
            color: var(--text-primary-dark);
            box-shadow: 0 3px 8px var(--shadow-dark);
            border: 1px solid var(--border-dark);
        }

        #notification-button .badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: var(--button-danger);
            color: white;
            font-size: 0.75rem;
            padding: 2px 7px;
            border-radius: 9999px;
            border: 1px solid var(--bg-card-light);
            font-weight: bold;
        }
        html.dark #notification-button .badge {
            border: 1px solid var(--bg-card-dark);
        }

        #notification-dropdown {
            position: absolute;
            top: 50px;
            left: 0;
            background-color: var(--bg-card-light);
            border-radius: 10px;
            box-shadow: 0 6px 15px var(--shadow-light);
            width: 280px;
            max-height: 400px;
            overflow-y: auto;
            padding: 12px;
            display: none;
            flex-direction: column;
            border: 1px solid var(--border-light);
        }
        html.dark #notification-dropdown {
            background-color: var(--bg-card-dark);
            box-shadow: 0 6px 15px var(--shadow-dark);
            border: 1px solid var(--border-dark);
        }
        #notification-dropdown.show {
            display: flex;
        }

        .notification-item {
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 4px;
            cursor: pointer;
            background-color: var(--bg-light);
            border: 1px solid var(--border-light);
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        html.dark .notification-item {
            background-color: var(--bg-dark);
            border: 1px solid var(--border-dark);
        }
        .notification-item:hover {
            background-color: var(--bg-column-light);
        }
        html.dark .notification-item:hover {
            background-color: var(--bg-column-dark);
        }

        .notification-item.unread {
            background-color: var(--unread-notification-bg-light);
            border-color: var(--button-primary);
        }
        html.dark .notification-item.unread {
            background-color: var(--unread-notification-bg-dark);
            border-color: var(--button-primary);
        }


        .notification-item-message {
            font-size: 0.9rem;
            color: var(--text-primary-light);
        }
        html.dark .notification-item-message {
            color: var(--text-primary-dark);
        }

        .notification-item-timestamp {
            font-size: 0.7rem;
            color: var(--text-secondary-light);
            margin-top: 4px;
            display: block;
        }
        html.dark .notification-item-timestamp {
            color: var(--text-secondary-dark);
        }

        /* Filter & Search styles */
        #filter-search-section {
            gap: 8px;
            margin-bottom: 15px;
            padding: 15px 25px;
            border-radius: 12px;
            box-shadow: 0 4px 12px var(--shadow-light);
            border: 1px solid var(--border-light);
            background-color: var(--bg-card-light);
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }
        html.dark #filter-search-section {
            box-shadow: 0 4px 12px var(--shadow-dark);
            border-color: var(--border-dark);
            background-color: var(--bg-card-dark);
        }
        #filter-search-section label {
            font-size: 0.85rem;
            color: var(--text-primary-light);
        }
        html.dark #filter-search-section label {
            color: var(--text-primary-dark);
        }
        #filter-search-section .input-field {
            padding: 8px 12px;
            font-size: 0.85rem;
        }
        #filter-search-section .input-field.w-32 {
            width: 24;
        }


        /* User settings modal */
        #user-settings-modal .modal-content {
            max-width: 550px;
            padding: 25px;
        }
        #user-settings-modal .settings-section {
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 10px;
            background-color: var(--bg-column-light);
            border: 1px solid var(--border-light);
        }
        html.dark #user-settings-modal .settings-section {
            background-color: var(--bg-column-dark);
            border: 1px solid var(--border-dark);
        }
        #user-settings-modal .settings-section h3 {
            font-size: 1.1rem;
            margin-bottom: 10px;
            color: var(--text-primary-light);
        }
        html.dark #user-settings-modal .settings-section h3 {
            color: var(--text-primary-dark);
        }
        #user-settings-modal .profile-avatar-preview {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background-color: var(--bg-column-light);
            color: var(--text-secondary-light);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            margin: 0 auto 10px;
            border: 2px solid var(--border-light);
            overflow: hidden;
        }
        html.dark #user-settings-modal .profile-avatar-preview {
            background-color: var(--bg-column-dark);
            color: var(--text-secondary-dark);
            border: 2px solid var(--border-dark);
        }
        #user-settings-modal .profile-avatar-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Custom Confirmation Modal */
        #confirmation-modal .modal-content {
            max-width: 400px;
            padding: 25px;
            text-align: center;
        }
        #confirmation-modal .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        /* Loading Spinner */
        .loading-spinner {
            width: 20px;
            height: 20px;
            border-width: 3px;
            border-style: solid;
            border-color: #f3f3f3 transparent #f3f3f3 transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Empty State */
        .empty-state {
            padding: 20px;
            text-align: center;
            color: var(--text-secondary-light);
            font-size: 0.9rem;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        html.dark .empty-state {
            color: var(--text-secondary-dark);
        }

        .empty-state i {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        /* User Avatar - Main UI */
        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--button-secondary); /* Neutral background for avatar fallback */
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            margin-right: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        .user-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Auth Modal specific styles */
        #auth-modal .modal-content {
            padding: 30px;
        }

        #auth-modal .auth-section {
            padding: 20px;
            margin-bottom: 15px;
            border-radius: 10px;
            background-color: var(--bg-column-light);
            border: 1px solid var(--border-light);
        }
        html.dark #auth-modal .auth-section {
            background-color: var(--bg-column-dark);
            border: 1px solid var(--border-dark);
        }

        #auth-modal .auth-toggle-link {
            margin-top: 10px;
            font-size: 0.85rem;
            text-align: center;
            color: var(--text-secondary-light);
        }
        html.dark #auth-modal .auth-toggle-link {
            color: var(--text-secondary-dark);
        }
        #auth-modal .auth-toggle-link span {
            color: var(--button-primary);
            cursor: pointer;
            font-weight: 600;
        }
        #auth-modal .auth-toggle-link span:hover {
            text-decoration: underline;
        }

        #auth-modal .error-message {
            font-size: 0.8rem;
            color: var(--button-danger);
            margin-top: 6px;
            text-align: center;
        }

        /* Add Task/Card Input within Column */
        .add-card-input-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }
        .add-card-input-container .input-field {
            width: 100%;
        }
        .add-card-button-in-column {
            background-color: var(--bg-column-light);
            color: var(--text-secondary-light);
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: 500;
            text-align: left;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 6px;
        }
        html.dark .add-card-button-in-column {
            background-color: var(--bg-column-dark);
            color: var(--text-secondary-dark);
        }
        .add-card-button-in-column:hover {
            background-color: var(--bg-column-light); /* Keep same background */
            color: var(--text-primary-light); /* Darken text */
        }
        html.dark .add-card-button-in-column:hover {
            background-color: var(--bg-column-dark);
            color: var(--text-primary-dark);
        }
        .add-card-button-in-column .fas {
            margin-right: 0; /* Remove margin as gap handles it */
        }

        /* Share Board Modal */
        #share-board-modal .modal-content {
            max-width: 500px;
        }
        #shareable-link-input {
            cursor: text;
        }
    </style>
</head>
<body>
    <div id="message-display" class="fixed top-5 left-1/2 -translate-x-1/2 px-4 py-2 rounded-lg shadow-lg z-50 transition-opacity duration-300 opacity-0"></div>

    <div id="notification-center">
        <button id="notification-button">
            <i class="fas fa-bell"></i>
            <span id="notification-badge" class="badge hidden">0</span>
        </button>
        <div id="notification-dropdown">
            <h3 class="text-lg font-bold text-gray-800 dark:text-gray-100 mb-3 text-center">Your Notifications</h3>
            <div id="notifications-list" class="flex-grow">
                </div>
            <button id="mark-all-read-button" class="action-button mt-4 py-2 px-4 text-sm bg-gray-500 hover:bg-gray-600">
                Mark All as Read
            </button>
        </div>
    </div>


    <div id="app-container" class="flex flex-col items-center md:items-start">
        <header id="main-header" class="w-full">
            <div class="flex items-center justify-between w-full">
                <div class="flex items-center gap-4">
                    <h1 class="text-2xl font-extrabold text-gray-900 dark:text-gray-100 hidden md:block">Ehab Board</h1>
                    <select id="board-selector" class="input-field py-2 px-3 text-sm"></select>
                    <div class="flex gap-2">
                        <button id="add-board-button" class="action-button bg-purple-500 hover:bg-purple-600 py-2 px-3 text-sm">
                            <i class="fas fa-plus"></i> Board
                        </button>
                        <button id="rename-board-button" class="action-button bg-blue-500 hover:bg-blue-600 py-2 px-3 text-sm">
                            <i class="fas fa-edit"></i> Board
                        </button>
                        <button id="delete-board-button" class="action-button bg-red-500 hover:bg-red-600 py-2 px-3 text-sm">
                            <i class="fas fa-trash-alt"></i> Board
                        </button>
                        <button id="share-board-button" class="action-button bg-teal-500 hover:bg-teal-600 py-2 px-3 text-sm">
                            <i class="fas fa-share-alt"></i> Share
                        </button>
                    </div>
                </div>

                <div class="flex-grow mx-4 relative hidden md:block">
                    <input type="text" id="task-search-input" placeholder="Search tasks..." class="input-field w-full pl-10 py-2">
                    <i class="fas fa-search absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 dark:text-gray-300"></i>
                </div>

                <div class="flex items-center gap-4">
                    <div id="user-info-block" class="flex items-center gap-2 hidden">
                        <div id="user-avatar" class="user-avatar"></div>
                        <span id="current-user-display-name" class="font-semibold"></span>
                        <div id="current-user-id" class="font-mono text-sm text-gray-500 dark:text-gray-400 hidden"></div> </div>
                    <button id="show-auth-modal-button" class="action-button hidden py-2 px-3 text-sm">Login</button>
                    <button id="logout-button" class="action-button hidden bg-red-500 hover:bg-red-600 py-2 px-3 text-sm">Logout</button>
                    <button id="user-settings-button" class="action-button hidden bg-gray-500 hover:bg-gray-600 py-2 px-3 text-sm"><i class="fas fa-cog"></i></button>
                </div>
            </div>

            <div class="flex flex-col md:hidden w-full mt-4 gap-3">
                <div class="relative w-full">
                    <input type="text" id="task-search-input-mobile" placeholder="Search tasks..." class="input-field w-full pl-10 py-2">
                    <i class="fas fa-search absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 dark:text-gray-300"></i>
                </div>
                <div class="flex gap-2 w-full justify-center">
                    <button id="add-column-button" class="action-button bg-gray-500 hover:bg-gray-600 flex-1"><i class="fas fa-plus"></i> Column</button>
                    <button id="rename-column-button" class="action-button bg-gray-500 hover:bg-gray-600 flex-1"><i class="fas fa-edit"></i> Column</button>
                    <button id="delete-column-button" class="action-button bg-gray-500 hover:bg-gray-600 flex-1"><i class="fas fa-trash-alt"></i> Column</button>
                </div>
            </div>
        </header>

        <div id="filter-search-section" class="flex flex-wrap gap-3 w-full hidden">
            <div class="filter-group">
                <label for="filter-status-select" class="text-sm">Status:</label>
                <select id="filter-status-select" class="input-field py-2 text-sm">
                    <option value="all">All</option>
                    </select>
            </div>
            <div class="filter-group">
                <label for="filter-assigned-to-input" class="text-sm">Assigned To:</label>
                <input type="text" id="filter-assigned-to-input" placeholder="Assignee name" class="input-field w-24 py-2 text-sm">
            </div>
            <div class="filter-group">
                <label for="filter-due-date-select" class="text-sm">Due Date:</label>
                <select id="filter-due-date-select" class="input-field py-2 text-sm">
                    <option value="all">All</option>
                    <option value="today">Today</option>
                    <option value="this-week">This Week</option>
                    <option value="overdue">Overdue</option>
                    <option value="no-date">No Date</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="filter-priority-select" class="text-sm">Priority:</label>
                <select id="filter-priority-select" class="input-field py-2 text-sm">
                    <option value="all">All</option>
                    <option value="high">High</option>
                    <option value="medium">Medium</option>
                    <option value="low">Low</option>
                    <option value="no-priority">No Priority</option>
                </select>
            </div>
        </div>

        <div id="kanban-board-wrapper" class="w-full flex-grow">
            <div id="kanban-board" class="hidden">
                <div id="add-column-placeholder">
                    <i class="fas fa-plus mr-2"></i> Add another column
                </div>
            </div>
        </div>
    </div>

    <canvas id="confetti-canvas"></canvas>

    <div id="auth-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-button" id="modal-close-button">&times;</button>
            <h2 id="auth-modal-title" class="text-2xl font-bold text-gray-800 dark:text-gray-100 mb-6 text-center">Login</h2>

            <div class="auth-section" id="email-auth-section">
                <div class="flex flex-col gap-4">
                    <input type="email" id="auth-email" placeholder="Email" class="input-field">
                    <input type="password" id="auth-password" placeholder="Password" class="input-field">
                    <p id="auth-error-message" class="error-message hidden"></p>
                    <button id="email-auth-button" class="action-button">Login</button>
                    <a href="#" id="forgot-password-link" class="text-center text-sm text-gray-500 dark:text-gray-400 hover:underline">Forgot password?</a>
                </div>
                <p id="toggle-auth-mode-link" class="auth-toggle-link">
                    Don't have an account? <span class="font-semibold">Sign Up</span>
                </p>
            </div>

            <div class="text-center text-gray-500 dark:text-gray-400 my-4">OR</div>

            <div class="flex flex-col gap-4">
                <button id="google-signin-button" class="google-signin-button">
                    <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google icon">
                    Sign in with Google
                </button>
                <button id="anonymous-login-button" class="action-button bg-gray-500 hover:bg-gray-600">
                    Login Anonymously
                </button>
            </div>
        </div>
    </div>

    <div id="create-board-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-button" id="create-board-modal-close-button">&times;</button>
            <h2 class="text-2xl font-bold text-gray-800 dark:text-gray-100 mb-6 text-center">Create New Board</h2>
            <div class="flex flex-col gap-4">
                <input type="text" id="new-board-name-input" placeholder="New board name" class="input-field">
                <button id="create-board-submit-button" class="action-button bg-purple-500 hover:bg-purple-600">Create Board</button>
            </div>
        </div>
    </div>

    <div id="rename-board-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-button" id="rename-board-modal-close-button">&times;</button>
            <h2 class="text-2xl font-bold text-gray-800 dark:text-gray-100 mb-6 text-center">Rename Board</h2>
            <div class="flex flex-col gap-4">
                <input type="text" id="rename-board-name-input" placeholder="New board name" class="input-field">
                <button id="rename-board-submit-button" class="action-button bg-blue-500 hover:bg-blue-600">Rename</button>
            </div>
        </div>
    </div>

    <div id="add-column-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-button" id="add-column-modal-close-button">&times;</button>
            <h2 class="text-2xl font-bold text-gray-800 dark:text-gray-100 mb-6 text-center">Add New Column</h2>
            <div class="flex flex-col gap-4">
                <input type="text" id="new-column-name-input" placeholder="New column name" class="input-field">
                <button id="add-column-submit-button" class="action-button bg-purple-500 hover:bg-purple-600">Add Column</button>
            </div>
        </div>
    </div>

    <div id="rename-column-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-button" id="rename-column-modal-close-button">&times;</button>
            <h2 class="text-2xl font-bold text-gray-800 dark:text-gray-100 mb-6 text-center">Rename Column</h2>
            <div class="flex flex-col gap-4">
                <select id="select-column-to-rename" class="input-field"></select>
                <input type="text" id="rename-column-name-input" placeholder="New column name" class="input-field">
                <button id="rename-column-submit-button" class="action-button bg-blue-500 hover:bg-blue-600">Rename</button>
            </div>
        </div>
    </div>

    <div id="delete-column-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-button" id="delete-column-modal-close-button">&times;</button>
            <h2 class="text-2xl font-bold text-gray-800 dark:text-gray-100 mb-6 text-center">Delete Column</h2>
            <div class="flex flex-col gap-4">
                <select id="select-column-to-delete" class="input-field"></select>
                <p class="text-red-600 dark:text-red-400 text-sm font-semibold">
                    <i class="fas fa-exclamation-triangle mr-1"></i> All tasks in this column will be moved to the "Backlog" column.
                </p>
                <button id="delete-column-submit-button" class="action-button bg-red-500 hover:bg-red-600">Delete Column</button>
            </div>
        </div>
    </div>


    <div id="task-detail-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-button" id="task-detail-modal-close-button">&times;</button>
            <div class="modal-body">
                <h2 class="text-2xl font-bold text-gray-800 dark:text-gray-100 mb-4">
                    <input type="text" id="task-detail-title" placeholder="Task Title" class="input-field text-2xl font-bold">
                </h2>

                <div class="detail-section">
                    <h3 class="flex justify-between items-center">
                        Description
                        <button id="elaborate-summarize-description-button" class="action-button py-1 px-3 text-sm bg-blue-500 hover:bg-blue-600">
                            <i class="fas fa-robot"></i> ✨ Elaborate/Summarize
                        </button>
                    </h3>
                    <textarea id="task-detail-description" placeholder="Add a detailed description for this task..." rows="4" class="input-field"></textarea>
                </div>

                <div class="detail-section flex flex-wrap gap-4">
                    <div class="flex-1 min-w-[200px]">
                        <h3>Due Date</h3>
                        <input type="date" id="task-detail-due-date" class="input-field">
                    </div>
                    <div class="flex-1 min-w-[200px]">
                        <h3>Assigned To</h3>
                        <input type="text" id="task-detail-assigned-to" placeholder="User name or ID" class="input-field">
                    </div>
                    <div class="flex-1 min-w-[200px]">
                        <h3>Priority</h3>
                        <select id="task-detail-priority" class="input-field">
                            <option value="no-priority">No Priority</option>
                            <option value="low">Low</option>
                            <option value="medium">Medium</option>
                            <option value="high">High</option>
                        </select>
                    </div>
                </div>

                <div class="detail-section">
                    <h3 class="flex justify-between items-center">
                        Checklists
                        <div class="flex gap-2">
                            <button id="add-checklist-button" class="action-button py-1 px-3 text-sm bg-gray-400 hover:bg-gray-500">
                                <i class="fas fa-plus"></i> Add Checklist
                            </button>
                            <button id="generate-checklist-button" class="action-button py-1 px-3 text-sm bg-purple-500 hover:bg-purple-600">
                                <i class="fas fa-magic"></i> ✨ Generate Checklist
                            </button>
                        </div>
                    </h3>
                    <div id="checklists-container">
                        </div>
                </div>

                <div class="detail-section">
                    <h3>Comments</h3>
                    <div id="comments-container">
                        </div>
                    <div class="flex gap-2 mt-4">
                        <textarea id="new-comment-input" placeholder="Write a comment..." rows="2" class="input-field flex-grow"></textarea>
                        <button id="add-comment-button" class="action-button py-2 px-4 text-sm">Add Comment</button>
                    </div>
                </div>

                <div class="detail-section">
                    <h3>Activity</h3>
                    <div id="activity-log-container">
                        </div>
                </div>
            </div>
        </div>
    </div>

    <div id="user-settings-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-button" id="user-settings-modal-close-button">&times;</button>
            <h2 class="text-2xl font-bold text-gray-800 dark:text-gray-100 mb-6 text-center">User Settings</h2>

            <div class="settings-section">
                <h3><i class="fas fa-user-circle mr-2"></i> Profile</h3>
                <div class="flex flex-col items-center mb-4">
                    <div id="profile-avatar-preview" class="profile-avatar-preview"></div>
                    <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Profile Picture (URL)</p>
                </div>
                <div class="flex flex-col gap-4">
                    <div class="flex flex-col gap-2">
                        <label for="display-name-input" class="text-gray-700 dark:text-gray-200 font-semibold">Display Name:</label>
                        <input type="text" id="display-name-input" placeholder="Your nickname" class="input-field">
                    </div>
                    <div class="flex flex-col gap-2">
                        <label for="profile-picture-url-input" class="text-gray-700 dark:text-gray-200 font-semibold">Profile Picture URL:</label>
                        <input type="text" id="profile-picture-url-input" placeholder="https://example.com/avatar.jpg" class="input-field">
                    </div>
                    <div class="flex flex-col gap-2">
                        <label for="user-bio-input" class="text-gray-700 dark:text-gray-200 font-semibold">About Me:</label>
                        <textarea id="user-bio-input" placeholder="Write a short bio about yourself..." rows="3" class="input-field"></textarea>
                    </div>
                    <div class="flex flex-col gap-2">
                        <label for="user-role-input" class="text-gray-700 dark:text-gray-200 font-semibold">Team Role:</label>
                        <input type="text" id="user-role-input" placeholder="e.g., Project Manager, Developer" class="input-field">
                    </div>
                    <div class="flex flex-col gap-2">
                        <label class="text-gray-700 dark:text-gray-200 font-semibold">Last Activity:</label>
                        <p id="last-activity-display" class="text-gray-600 dark:text-gray-300 text-sm"></p>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <h3><i class="fas fa-cogs mr-2"></i> App Settings</h3>
                <div class="flex flex-col gap-4">
                    <div class="flex items-center justify-between">
                        <label for="dark-mode-toggle" class="text-gray-700 dark:text-gray-200 font-semibold">Dark Mode</label>
                        <input type="checkbox" id="dark-mode-toggle" class="h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="notifications-toggle" class="text-gray-700 dark:text-gray-200 font-semibold">Enable Notifications</label>
                        <input type="checkbox" id="notifications-toggle" class="h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex flex-col gap-2">
                        <label for="board-background-type" class="text-gray-700 dark:text-gray-200 font-semibold">Board Background Type:</label>
                        <select id="board-background-type" class="input-field">
                            <option value="none">None</option>
                            <option value="color">Solid Color</option>
                            <option value="image">Image URL</option>
                            <option value="gradient1">Gradient 1 (Blue-Purple)</option>
                            <option value="gradient2">Gradient 2 (Green-Yellow)</option>
                        </select>
                    </div>
                    <div id="board-background-color-group" class="flex flex-col gap-2 hidden">
                        <label for="board-background-color" class="text-gray-700 dark:text-gray-200 font-semibold">Solid Color:</label>
                        <input type="color" id="board-background-color" class="w-full h-10 border border-gray-300 rounded-md cursor-pointer">
                    </div>
                    <div id="board-background-image-group" class="flex flex-col gap-2 hidden">
                        <label for="board-background-image" class="text-gray-700 dark:text-gray-200 font-semibold">Board Background Image (URL):</label>
                        <input type="text" id="board-background-image" placeholder="https://placehold.co/1200x800/000000/FFFFFF?text=Board+Image" class="input-field">
                    </div>
                </div>
            </div>
            <button id="save-user-settings-button" class="action-button bg-green-500 hover:bg-green-600 w-full">Save Settings</button>
        </div>
    </div>

    <div id="confirmation-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="confirmation-message" class="text-lg font-bold text-gray-800 dark:text-gray-100 mb-4">Are you sure?</h3>
            <div class="modal-buttons">
                <button id="confirm-yes-button" class="action-button bg-red-500 hover:bg-red-600">Yes</button>
                <button id="confirm-no-button" class="action-button bg-gray-500 hover:bg-gray-600">Cancel</button>
            </div>
        </div>
    </div>

    <div id="share-board-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-button" id="share-board-modal-close-button">&times;</button>
            <h2 class="text-2xl font-bold text-gray-800 dark:text-gray-100 mb-6 text-center">Share Board</h2>
            <p class="text-gray-700 dark:text-gray-300 mb-4 text-center">Share this link to allow others to view this board.</p>
            <div class="flex flex-col gap-4">
                <input type="text" id="shareable-link-input" class="input-field text-center" readonly>
                <button id="copy-share-link-button" class="action-button bg-blue-500 hover:bg-blue-600"><i class="fas fa-copy"></i> Copy Link</button>
                <p class="text-sm text-gray-600 dark:text-gray-400 text-center mt-2">
                    <i class="fas fa-info-circle"></i> This link provides read-only access. For full collaboration (write access), Firebase Firestore security rules must be configured on the server.
                </p>
            </div>
        </div>
    </div>


    <script type="module">
        // Firebase SDK imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut, createUserWithEmailAndPassword, signInWithEmailAndPassword, GoogleAuthProvider, signInWithPopup, sendPasswordResetEmail } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, orderBy, serverTimestamp, arrayUnion, arrayRemove, getDocs, writeBatch, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables for Firebase and app state
        let app;
        let db;
        let auth;
        let userId = 'anonymous';
        let userDisplayName = 'Anonymous';
        let tasksCollectionRef;
        let boardsCollectionRef;
        let usersCollectionRef;
        let currentBoardId = null;
        let currentTaskId = null;
        let isAuthReady = false;
        let isLoginMode = true;

        let unsubscribeFromTasks = null;
        let unsubscribeFromBoards = null;
        let unsubscribeFromNotifications = null;
        let unsubscribeFromUserSettings = null;
        let unsubscribeFromTaskDetails = [];

        // Store current board's columns
        let currentBoardColumns = [];

        // Get app ID and Firebase config from the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-kanban-app';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

        // DOM Elements
        // Removed global newTaskInput and addTaskButton, now per-column
        const kanbanBoardWrapper = document.getElementById('kanban-board-wrapper');
        const kanbanBoard = document.getElementById('kanban-board');
        const userInfoBlock = document.getElementById('user-info-block');
        const currentUserIdDisplay = document.getElementById('current-user-id');
        const currentUserDisplayName = document.getElementById('current-user-display-name');
        const userAvatar = document.getElementById('user-avatar');
        const showAuthModalButton = document.getElementById('show-auth-modal-button');
        const logoutButton = document.getElementById('logout-button');
        // Removed taskInputSection
        // Removed boardManagementSection as its elements are now in the header directly
        const boardSelector = document.getElementById('board-selector');
        const addBoardButton = document.getElementById('add-board-button');
        const renameBoardButton = document.getElementById('rename-board-button');
        const deleteBoardButton = document.getElementById('delete-board-button');
        const shareBoardButton = document.getElementById('share-board-button');
        const userSettingsButton = document.getElementById('user-settings-button');

        // Auth Modal Elements
        const authModal = document.getElementById('auth-modal');
        const modalCloseButton = document.getElementById('modal-close-button');
        const authModalTitle = document.getElementById('auth-modal-title');
        const authEmailInput = document.getElementById('auth-email');
        const authPasswordInput = document.getElementById('auth-password');
        const authErrorMessage = document.getElementById('auth-error-message');
        const emailAuthButton = document.getElementById('email-auth-button');
        const forgotPasswordLink = document.getElementById('forgot-password-link');
        const toggleAuthModeLink = document.getElementById('toggle-auth-mode-link');
        const googleSigninButton = document.getElementById('google-signin-button');
        const anonymousLoginButton = document.getElementById('anonymous-login-button');

        // Create Board Modal Elements
        const createBoardModal = document.getElementById('create-board-modal');
        const createBoardModalCloseButton = document.getElementById('create-board-modal-close-button');
        const newBoardNameInput = document.getElementById('new-board-name-input');
        const createBoardSubmitButton = document.getElementById('create-board-submit-button');

        // Rename Board Modal Elements
        const renameBoardModal = document.getElementById('rename-board-modal');
        const renameBoardModalCloseButton = document.getElementById('rename-board-modal-close-button');
        const renameBoardNameInput = document.getElementById('rename-board-name-input');
        const renameBoardSubmitButton = document.getElementById('rename-board-submit-button');

        // Column Management Modals and Buttons
        const addColumnButton = document.getElementById('add-column-button');
        const renameColumnButton = document.getElementById('rename-column-button');
        const deleteColumnButton = document.getElementById('delete-column-button');
        const addColumnPlaceholder = document.getElementById('add-column-placeholder'); // The "Add another column" button on the board

        const addColumnModal = document.getElementById('add-column-modal');
        const addColumnModalCloseButton = document.getElementById('add-column-modal-close-button');
        const newColumnNameInput = document.getElementById('new-column-name-input');
        const addColumnSubmitButton = document.getElementById('add-column-submit-button');

        const renameColumnModal = document.getElementById('rename-column-modal');
        const renameColumnModalCloseButton = document.getElementById('rename-column-modal-close-button');
        const selectColumnToRename = document.getElementById('select-column-to-rename');
        const renameColumnNameInput = document.getElementById('rename-column-name-input');
        const renameColumnSubmitButton = document.getElementById('rename-column-submit-button');

        const deleteColumnModal = document.getElementById('delete-column-modal');
        const deleteColumnModalCloseButton = document.getElementById('delete-column-modal-close-button');
        const selectColumnToDelete = document.getElementById('select-column-to-delete');
        const deleteColumnSubmitButton = document.getElementById('delete-column-submit-button');


        // Task Detail Modal Elements
        const taskDetailModal = document.getElementById('task-detail-modal');
        const taskDetailModalCloseButton = document.getElementById('task-detail-modal-close-button');
        const taskDetailTitleInput = document.getElementById('task-detail-title');
        const taskDetailDescriptionInput = document.getElementById('task-detail-description');
        const elaborateSummarizeDescriptionButton = document.getElementById('elaborate-summarize-description-button'); // New button
        const taskDetailDueDateInput = document.getElementById('task-detail-due-date');
        const taskDetailAssignedToInput = document.getElementById('task-detail-assigned-to');
        const taskDetailPrioritySelect = document.getElementById('task-detail-priority');
        const addChecklistButton = document.getElementById('add-checklist-button');
        const generateChecklistButton = document.getElementById('generate-checklist-button'); // New LLM button
        const checklistsContainer = document.getElementById('checklists-container');
        const commentsContainer = document.getElementById('comments-container');
        const newCommentInput = document.getElementById('new-comment-input');
        const addCommentButton = document.getElementById('add-comment-button');
        const activityLogContainer = document.getElementById('activity-log-container');

        // Confetti Canvas Elements
        const confettiCanvas = document.getElementById('confetti-canvas');
        const confettiCtx = confettiCanvas.getContext('2d');
        let confettiParticles = [];
        let animationFrameId = null;

        // Message Display Element
        const messageDisplay = document.getElementById('message-display');
        let messageTimeoutId = null;

        // Filter & Search Elements
        const filterSearchSection = document.getElementById('filter-search-section');
        const taskSearchInput = document.getElementById('task-search-input'); // Desktop search
        const taskSearchInputMobile = document.getElementById('task-search-input-mobile'); // Mobile search
        const filterStatusSelect = document.getElementById('filter-status-select');
        const filterAssignedToInput = document.getElementById('filter-assigned-to-input');
        const filterDueDateSelect = document.getElementById('filter-due-date-select');
        const filterPrioritySelect = document.getElementById('filter-priority-select');
        let allTasksData = [];

        // Notification Elements
        const notificationButton = document.getElementById('notification-button');
        const notificationBadge = document.getElementById('notification-badge');
        const notificationDropdown = document.getElementById('notification-dropdown');
        const notificationsList = document.getElementById('notifications-list');
        const markAllReadButton = document.getElementById('mark-all-read-button');
        let unreadNotificationsCount = 0;

        // User Settings Elements
        const userSettingsModal = document.getElementById('user-settings-modal');
        const userSettingsModalCloseButton = document.getElementById('user-settings-modal-close-button');
        const profileAvatarPreview = document.getElementById('profile-avatar-preview');
        const displayNameInput = document.getElementById('display-name-input');
        const profilePictureUrlInput = document.getElementById('profile-picture-url-input');
        const userBioInput = document.getElementById('user-bio-input');
        const userRoleInput = document.getElementById('user-role-input');
        const lastActivityDisplay = document.getElementById('last-activity-display');
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const notificationsToggle = document.getElementById('notifications-toggle');
        const boardBackgroundTypeSelect = document.getElementById('board-background-type');
        const boardBackgroundColorGroup = document.getElementById('board-background-color-group');
        const boardBackgroundImageGroup = document.getElementById('board-background-image-group');
        const boardBackgroundColorInput = document.getElementById('board-background-color');
        const boardBackgroundImageInput = document.getElementById('board-background-image');
        const saveUserSettingsButton = document.getElementById('save-user-settings-button');
        let currentUserSettings = {
            displayName: 'Anonymous',
            profilePictureUrl: '',
            bio: '',
            role: '',
            lastActivity: null,
            darkModeEnabled: false,
            notificationsEnabled: true,
            boardBackgroundType: 'none',
            boardBackgroundValue: '',
        };

        // Custom Confirmation Modal Elements
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationMessage = document.getElementById('confirmation-message');
        const confirmYesButton = document.getElementById('confirm-yes-button');
        const confirmNoButton = document.getElementById('confirm-no-button');
        let confirmationCallback = null;

        // Share Board Modal Elements
        const shareBoardModal = document.getElementById('share-board-modal');
        const shareBoardModalCloseButton = document.getElementById('share-board-modal-close-button');
        const shareableLinkInput = document.getElementById('shareable-link-input');
        const copyShareLinkButton = document.getElementById('copy-share-link-button');


        /**
         * Displays a temporary message to the user.
         * @param {string} message - The message to display.
         * @param {string} type - 'success', 'error', or 'info'.
         */
        const showMessage = (message, type = 'info') => {
            if (messageTimeoutId) {
                clearTimeout(messageTimeoutId);
            }
            messageDisplay.textContent = message;
            messageDisplay.className = `fixed top-5 left-1/2 -translate-x-1/2 px-4 py-2 rounded-lg shadow-lg z-50 transition-opacity duration-300 opacity-0`;
            if (type === 'success') {
                messageDisplay.classList.add('success');
            } else if (type === 'error') {
                messageDisplay.classList.add('error');
            } else { // info
                messageDisplay.classList.add('info');
            }
            messageDisplay.classList.add('show');

            messageTimeoutId = setTimeout(() => {
                messageDisplay.classList.remove('show');
            }, 3000);
        };

        /**
         * Shows a custom confirmation modal.
         * @param {string} message - The confirmation message.
         * @param {function} callback - The function to call if confirmed (true) or cancelled (false).
         */
        const showConfirmationModal = (message, callback) => {
            confirmationMessage.textContent = message;
            confirmationCallback = callback;
            confirmationModal.classList.add('show');
        };

        /**
         * Displays an authentication error message.
         * @param {string} message - The error message to display.
         */
        const showAuthError = (message) => {
            authErrorMessage.textContent = message;
            authErrorMessage.classList.remove('hidden');
        };

        /**
         * Clears the authentication error message.
         */
        const clearAuthError = () => {
            authErrorMessage.textContent = '';
            authErrorMessage.classList.add('hidden');
        };

        /**
         * Toggles the auth modal between login and registration modes.
         */
        const toggleAuthMode = () => {
            isLoginMode = !isLoginMode;
            clearAuthError();
            authEmailInput.value = '';
            authPasswordInput.value = '';
            if (isLoginMode) {
                authModalTitle.textContent = 'Login';
                emailAuthButton.textContent = 'Login';
                emailAuthButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                emailAuthButton.classList.add('bg-blue-500', 'hover:bg-blue-600');
                toggleAuthModeLink.innerHTML = "Don't have an account? <span class=\"font-semibold\">Sign Up</span>";
                forgotPasswordLink.classList.remove('hidden');
            } else {
                authModalTitle.textContent = 'Create New Account';
                emailAuthButton.textContent = 'Sign Up';
                emailAuthButton.classList.remove('bg-blue-500', 'hover:bg-blue-600');
                emailAuthButton.classList.add('bg-green-500', 'hover:bg-green-600');
                toggleAuthModeLink.innerHTML = 'Already have an account? <span class="font-semibold">Login</span>';
                forgotPasswordLink.classList.add('hidden');
            }
        };

        // --- Firebase Initialization and Authentication ---
        const initializeFirebase = async () => {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                usersCollectionRef = collection(db, `artifacts/${appId}/users`);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        userInfoBlock.classList.remove('hidden');
                        
                        const userDocRef = doc(usersCollectionRef, userId);
                        const userDocSnap = await getDoc(userDocRef);
                        if (userDocSnap.exists()) {
                            currentUserSettings = { ...currentUserSettings, ...userDocSnap.data() };
                            userDisplayName = currentUserSettings.displayName || 'Anonymous';
                        } else {
                            await setDoc(userDocRef, { ...currentUserSettings, displayName: user.displayName || user.email?.split('@')[0] || 'Anonymous', lastActivity: serverTimestamp() }, { merge: true });
                            userDisplayName = currentUserSettings.displayName;
                        }

                        await updateDoc(userDocRef, { lastActivity: serverTimestamp() }, { merge: true });

                        currentUserDisplayName.textContent = userDisplayName;
                        currentUserIdDisplay.textContent = userId;
                        updateUserAvatar(currentUserSettings.profilePictureUrl, userDisplayName);

                        console.log("User signed in:", userId, "Display Name:", userDisplayName);

                        boardsCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/boards`);
                        isAuthReady = true;

                        setupUserSettingsListener();
                        setupNotificationListener();

                        setupBoardListener();
                        showAuthModalButton.classList.add('hidden');
                        logoutButton.classList.remove('hidden');
                        userSettingsButton.classList.remove('hidden');
                        authModal.classList.remove('show');

                        filterSearchSection.classList.remove('hidden'); // Filters are still visible
                        kanbanBoard.classList.remove('hidden');

                    } else {
                        userId = 'Not Signed In';
                        userDisplayName = 'Anonymous';
                        currentUserIdDisplay.textContent = userId;
                        currentUserDisplayName.textContent = userDisplayName;
                        userInfoBlock.classList.add('hidden');
                        userAvatar.innerHTML = '';
                        console.log("No user signed in.");

                        isAuthReady = false;
                        currentBoardId = null;
                        clearTasksFromUI();

                        if (unsubscribeFromTasks) { unsubscribeFromTasks(); unsubscribeFromTasks = null; }
                        if (unsubscribeFromBoards) { unsubscribeFromBoards(); unsubscribeFromBoards = null; }
                        if (unsubscribeFromNotifications) { unsubscribeFromNotifications(); unsubscribeFromNotifications = null; }
                        if (unsubscribeFromUserSettings) { unsubscribeFromUserSettings(); unsubscribeFromUserSettings = null; }
                        unsubscribeFromTaskDetails.forEach(unsub => unsub());
                        unsubscribeFromTaskDetails = [];

                        kanbanBoard.classList.add('hidden');
                        filterSearchSection.classList.add('hidden');
                        showAuthModalButton.classList.remove('hidden');
                        logoutButton.classList.add('hidden');
                        userSettingsButton.classList.add('hidden');
                        authModal.classList.add('show');
                        toggleAuthMode();

                        document.documentElement.classList.remove('dark');
                        document.getElementById('app-container').style.backgroundColor = '';
                        document.getElementById('app-container').style.backgroundImage = '';
                    }
                    addDragAndDropListeners();
                });

                if (!auth.currentUser && typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    try {
                        await signInWithCustomToken(auth, __initial_auth_token);
                        showMessage("Signed in automatically.", 'info');
                    } catch (error) {
                        console.error("Error signing in with custom token:", error);
                        showMessage("Automatic sign-in failed.", 'error');
                    }
                } else if (!auth.currentUser) {
                    authModal.classList.add('show');
                    toggleAuthMode();
                }

            } catch (error) {
                console.error("Error initializing Firebase:", error);
                currentUserIdDisplay.textContent = `Error: ${error.message}`;
                showMessage("Firebase initialization failed: " + error.message, 'error');
            }
        };

        /**
         * Updates the user avatar in the main UI and settings preview.
         * @param {string} imageUrl - URL of the profile picture.
         * @param {string} displayName - User's display name for initials fallback.
         */
        const updateUserAvatar = (imageUrl, displayName) => {
            const avatarElement = userAvatar;
            const previewElement = profileAvatarPreview;

            [avatarElement, previewElement].forEach(element => {
                element.innerHTML = ''; // Clear previous content
                if (imageUrl) {
                    const img = document.createElement('img');
                    img.src = imageUrl;
                    img.alt = displayName.charAt(0).toUpperCase();
                    img.onerror = () => {
                        // Fallback to initials if image fails to load
                        element.textContent = displayName.charAt(0).toUpperCase();
                    };
                    element.appendChild(img);
                } else {
                    element.textContent = displayName.charAt(0).toUpperCase();
                }
            });
        };

        // --- Auth Actions ---

        /**
         * Validates email and password inputs.
         * @param {string} email - The email to validate.
         * @param {string} password - The password to validate.
         * @param {boolean} isRegister - True if validating for registration, false for login.
         * @returns {string|null} - An error message if validation fails, otherwise null.
         */
        const validateAuthInputs = (email, password, isRegister) => {
            if (!email) {
                return "Please enter an email.";
            }
            if (!/\S+@\S+\.\S+/.test(email)) {
                return "Invalid email format.";
            }
            if (!password) {
                return "Please enter a password.";
            }
            if (isRegister && password.length < 6) {
                return "Password must be at least 6 characters long.";
            }
            return null;
        };

        const handleEmailAuth = async () => {
            clearAuthError();
            const email = authEmailInput.value.trim();
            const password = authPasswordInput.value.trim();

            const validationError = validateAuthInputs(email, password, !isLoginMode);
            if (validationError) {
                showAuthError(validationError);
                return;
            }

            emailAuthButton.innerHTML = '<span class="loading-spinner"></span>';
            emailAuthButton.disabled = true;

            try {
                if (isLoginMode) {
                    await signInWithEmailAndPassword(auth, email, password);
                    showMessage("Logged in successfully!", 'success');
                } else {
                    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                    const defaultDisplayName = email.split('@')[0];
                    await setDoc(doc(usersCollectionRef, userCredential.user.uid), { ...currentUserSettings, displayName: defaultDisplayName, lastActivity: serverTimestamp() });
                    showMessage("Account created and logged in successfully!", 'success');
                }
                authModal.classList.remove('show');
            }
            catch (error) {
                console.error("Error during email auth:", error);
                let errorMessage = "An error occurred. Please try again.";
                if (error.code === 'auth/email-already-in-use') {
                    errorMessage = "This email is already in use.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Invalid email format.";
                } else if (error.code === 'auth/weak-password') {
                    errorMessage = "Password is too weak.";
                } else if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password') {
                    errorMessage = "Incorrect email or password.";
                }
                showAuthError(errorMessage);
            } finally {
                emailAuthButton.innerHTML = isLoginMode ? 'Login' : 'Sign Up';
                emailAuthButton.disabled = false;
            }
        };

        const handleForgotPassword = async () => {
            clearAuthError();
            const email = authEmailInput.value.trim();
            if (!email || !/\S+@\S+\.\S+/.test(email)) {
                showAuthError("Please enter a valid email to reset password.");
                return;
            }

            try {
                await sendPasswordResetEmail(auth, email);
                showMessage("Password reset link sent to your email.", 'info');
                authModal.classList.remove('show');
            } catch (error) {
                console.error("Error sending password reset email:", error);
                let errorMessage = "Failed to send password reset link.";
                if (error.code === 'auth/user-not-found') {
                    errorMessage = "No account found with this email.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Invalid email format.";
                }
                showAuthError(errorMessage);
            }
        };

        const handleGoogleLogin = async () => {
            try {
                const provider = new GoogleAuthProvider();
                const userCredential = await signInWithPopup(auth, provider);
                const userDocRef = doc(usersCollectionRef, userCredential.user.uid);
                const userDocSnap = await getDoc(userDocRef);
                if (!userDocSnap.exists()) {
                    await setDoc(userDocRef, { ...currentUserSettings, displayName: userCredential.user.displayName || userCredential.user.email.split('@')[0], lastActivity: serverTimestamp() });
                }
                showMessage("Signed in with Google successfully!", 'success');
                authModal.classList.remove('show');
            } catch (error) {
                console.error("Error during Google sign-in:", error);
                let errorMessage = "Google sign-in failed.";
                if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = "Sign-in popup closed.";
                } else if (error.code === 'auth/cancelled-popup-request') {
                    errorMessage = "Sign-in popup request cancelled.";
                }
                showMessage(errorMessage, 'error');
            }
        };

        const handleAnonymousLogin = async () => {
            try {
                const userCredential = await signInAnonymously(auth);
                await setDoc(doc(usersCollectionRef, userCredential.user.uid), { ...currentUserSettings, displayName: 'Anonymous', lastActivity: serverTimestamp() });
                showMessage("Logged in anonymously successfully!", 'success');
                authModal.classList.remove('show');
            } catch (error) {
                console.error("Error during anonymous sign-in:", error);
                showMessage("Anonymous login failed.", 'error');
            }
        };

        const handleLogout = async () => {
            try {
                await signOut(auth);
                showMessage("Logged out successfully.", 'info');
            } catch (error) {
                console.error("Error during logout:", error);
                showMessage("Logout failed: " + error.message, 'error');
            }
        };

        // --- Board Management Functions ---

        /**
         * Sets up a real-time listener for boards from Firestore.
         */
        const setupBoardListener = () => {
            if (!isAuthReady || !boardsCollectionRef) {
                console.warn("Firebase authentication not ready or boards collection ref not set, delaying board listener setup.");
                return;
            }

            if (unsubscribeFromBoards) {
                unsubscribeFromBoards();
            }

            const q = query(boardsCollectionRef, orderBy('createdAt'));

            unsubscribeFromBoards = onSnapshot(q, (querySnapshot) => {
                boardSelector.innerHTML = '';
                let firstBoardId = null;
                let foundCurrentBoard = false;

                if (querySnapshot.empty) {
                    showMessage("No boards found. Please create a new board.", 'info');
                    createBoardModal.classList.add('show');
                    kanbanBoard.classList.add('hidden');
                    filterSearchSection.classList.add('hidden');
                    currentBoardId = null;
                } else {
                    querySnapshot.forEach((doc) => {
                        const boardData = doc.data();
                        const option = document.createElement('option');
                        option.value = doc.id;
                        option.textContent = boardData.name;
                        boardSelector.appendChild(option);

                        if (!firstBoardId) {
                            firstBoardId = doc.id;
                        }
                        if (doc.id === currentBoardId) {
                            foundCurrentBoard = true;
                        }
                    });

                    if (currentBoardId && foundCurrentBoard) {
                        boardSelector.value = currentBoardId;
                    } else if (firstBoardId) {
                        boardSelector.value = firstBoardId;
                        currentBoardId = firstBoardId;
                    } else {
                        currentBoardId = null;
                    }

                    if (currentBoardId) {
                        selectBoard(currentBoardId);
                        kanbanBoard.classList.remove('hidden');
                        filterSearchSection.classList.remove('hidden');
                    } else {
                        clearTasksFromUI();
                        if (unsubscribeFromTasks) { unsubscribeFromTasks(); unsubscribeFromTasks = null; }
                        kanbanBoard.classList.add('hidden');
                        filterSearchSection.classList.add('hidden');
                        showMessage("Active board not found. Please select or create a new board.", 'info');
                    }
                }
                console.log("Boards updated from Firestore.");
            }, (error) => {
                console.error("Error fetching boards:", error);
                showMessage("Error loading boards: " + error.message, 'error');
            });
        };

        /**
         * Selects a board and loads its tasks.
         * @param {string} boardId - The ID of the board to select.
         */
        const selectBoard = async (boardId) => {
            if (!boardId) {
                console.warn("No board ID provided for selection.");
                clearTasksFromUI();
                if (unsubscribeFromTasks) { unsubscribeFromTasks(); unsubscribeFromTasks = null; }
                kanbanBoard.classList.add('hidden');
                filterSearchSection.classList.add('hidden');
                return;
            }

            currentBoardId = boardId;
            tasksCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks`);
            
            // Fetch board columns
            const boardDocRef = doc(db, `artifacts/${appId}/users/${userId}/boards`, currentBoardId);
            const boardDocSnap = await getDoc(boardDocRef);
            if (boardDocSnap.exists() && boardDocSnap.data().columns) {
                currentBoardColumns = boardDocSnap.data().columns.sort((a, b) => a.order - b.order);
            } else {
                // Default columns if not found or new board
                currentBoardColumns = [
                    { id: 'backlog', name: 'Backlog', order: 0 },
                    { id: 'todo', name: 'To Do', order: 1 },
                    { id: 'inprogress', name: 'In Progress', order: 2 },
                    { id: 'review', name: 'Review', order: 3 },
                    { id: 'done', name: 'Done', order: 4 }
                ];
                // Save default columns to new board
                await setDoc(boardDocRef, { columns: currentBoardColumns }, { merge: true }); // Use setDoc for initial creation if it's a new board
            }

            renderKanbanColumns(); // Render columns based on currentBoardColumns
            setupTaskListener();
            addDragAndDropListeners(); // Re-add drag and drop listeners for new columns

            console.log(`Board selected: ${currentBoardId}`);
            const selectedOption = boardSelector.options[boardSelector.selectedIndex];
            if (selectedOption) {
                showMessage(`Board selected: ${selectedOption.textContent}`, 'info');
            }

            applyBoardBackground(currentUserSettings.boardBackgroundType, currentUserSettings.boardBackgroundValue);

            kanbanBoard.classList.remove('hidden');
            filterSearchSection.classList.remove('hidden');
        };

        /**
         * Renders the Kanban columns dynamically based on `currentBoardColumns`.
         */
        const renderKanbanColumns = () => {
            kanbanBoard.innerHTML = ''; // Clear existing columns
            filterStatusSelect.innerHTML = '<option value="all">All</option>'; // Reset filter options

            currentBoardColumns.forEach(column => {
                const columnDiv = document.createElement('div');
                columnDiv.id = `${column.id}-column`;
                columnDiv.className = 'kanban-column';
                columnDiv.dataset.status = column.id;
                columnDiv.innerHTML = `
                    <h2 class="column-title">${column.name}</h2>
                    <div class="column-cards flex flex-col gap-3 flex-grow">
                        <div class="empty-state hidden">
                            <i class="fas fa-clipboard-list"></i>
                            <p>No tasks here yet!</p>
                        </div>
                    </div>
                    <button class="add-card-button-in-column" data-column-id="${column.id}">
                        <i class="fas fa-plus"></i> Add card
                    </button>
                    <div class="add-card-input-container hidden">
                        <input type="text" placeholder="Card title..." class="input-field add-card-input">
                        <div class="flex gap-2">
                            <button class="action-button py-1 px-3 text-sm add-card-submit-button">Add Card</button>
                            <button class="action-button py-1 px-3 text-sm bg-gray-400 hover:bg-gray-500 cancel-add-card-button">&times;</button>
                        </div>
                    </div>
                `;
                kanbanBoard.appendChild(columnDiv);

                // Add to filter options
                const option = document.createElement('option');
                option.value = column.id;
                option.textContent = column.name;
                filterStatusSelect.appendChild(option);
            });

            // Re-append the "Add another column" placeholder
            kanbanBoard.appendChild(addColumnPlaceholder);

            // Attach event listeners for new add card buttons
            kanbanBoard.querySelectorAll('.add-card-button-in-column').forEach(button => {
                button.addEventListener('click', (e) => {
                    const columnDiv = e.target.closest('.kanban-column');
                    columnDiv.querySelector('.add-card-button-in-column').classList.add('hidden');
                    columnDiv.querySelector('.add-card-input-container').classList.remove('hidden');
                    columnDiv.querySelector('.add-card-input').focus();
                });
            });

            kanbanBoard.querySelectorAll('.cancel-add-card-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const columnDiv = e.target.closest('.kanban-column');
                    columnDiv.querySelector('.add-card-button-in-column').classList.remove('hidden');
                    columnDiv.querySelector('.add-card-input-container').classList.add('hidden');
                    columnDiv.querySelector('.add-card-input').value = '';
                });
            });

            kanbanBoard.querySelectorAll('.add-card-submit-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const columnDiv = e.target.closest('.kanban-column');
                    const input = columnDiv.querySelector('.add-card-input');
                    const columnId = columnDiv.dataset.status;
                    handleAddCardInColumn(input.value, columnId, input, columnDiv.querySelector('.add-card-button-in-column'), columnDiv.querySelector('.add-card-input-container'));
                });
            });

            kanbanBoard.querySelectorAll('.add-card-input').forEach(input => {
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const columnDiv = e.target.closest('.kanban-column');
                        const columnId = columnDiv.dataset.status;
                        handleAddCardInColumn(input.value, columnId, input, columnDiv.querySelector('.add-card-button-in-column'), columnDiv.querySelector('.add-card-input-container'));
                    }
                });
            });

            // Ensure empty states are correctly applied initially
            currentBoardColumns.forEach(column => updateEmptyState(column.id));
        };


        /**
         * Handles the creation of a new board.
         */
        const handleCreateBoard = async () => {
            const boardName = newBoardNameInput.value.trim();
            if (!boardName) {
                showMessage("Please enter a board name.", 'error');
                return;
            }

            if (!isAuthReady || !boardsCollectionRef) {
                showMessage("Please log in to create boards.", 'error');
                return;
            }

            try {
                // Define default columns for a new board
                const defaultColumns = [
                    { id: 'backlog', name: 'Backlog', order: 0 },
                    { id: 'todo', name: 'To Do', order: 1 },
                    { id: 'inprogress', name: 'In Progress', order: 2 },
                    { id: 'review', name: 'Review', order: 3 },
                    { id: 'done', name: 'Done', order: 4 }
                ];

                const newBoardRef = await addDoc(boardsCollectionRef, {
                    name: boardName,
                    createdAt: serverTimestamp(),
                    columns: defaultColumns // Save default columns with the new board
                });
                newBoardNameInput.value = '';
                createBoardModal.classList.remove('show');
                showMessage(`Board "${boardName}" created successfully!`, 'success');
            } catch (error) {
                console.error("Error creating board:", error);
                showMessage("Error creating board: " + error.message, 'error');
            }
        };

        /**
         * Handles renaming the current board.
         */
        const handleRenameBoard = async () => {
            if (!currentBoardId) {
                showMessage("Please select a board to rename.", 'error');
                return;
            }
            const newName = renameBoardNameInput.value.trim();
            if (!newName) {
                showMessage("Please enter a new board name.", 'error');
                return;
            }

            try {
                const boardRef = doc(db, `artifacts/${appId}/users/${userId}/boards`, currentBoardId);
                await updateDoc(boardRef, { name: newName });
                renameBoardModal.classList.remove('show');
                showMessage(`Board renamed to "${newName}" successfully!`, 'success');
            } catch (error) {
                console.error("Error renaming board:", error);
                showMessage("Error renaming board: " + error.message, 'error');
            }
        };

        /**
         * Handles deleting the current board.
         */
        const handleDeleteBoard = async () => {
            if (!currentBoardId) {
                showMessage("Please select a board to delete.", 'error');
                return;
            }

            showConfirmationModal("Are you sure you want to delete this board and all its tasks? This action cannot be undone.", async (confirmed) => {
                if (!confirmed) {
                    return;
                }

                try {
                    const tasksQuery = query(collection(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks`));
                    const tasksSnapshot = await getDocs(tasksQuery);
                    const deletePromises = [];
                    tasksSnapshot.forEach((taskDoc) => {
                        const taskDocRef = doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks`, taskDoc.id);
                        const subcollections = ['checklists', 'comments', 'activities'];
                        subcollections.forEach(sub => {
                            getDocs(collection(taskDocRef, sub)).then(subSnap => { // Corrected: use collection(taskDocRef, sub)
                                subSnap.forEach(sDoc => {
                                    deletePromises.push(deleteDoc(doc(collection(taskDocRef, sub), sDoc.id))); // Corrected: use doc(collection(taskDocRef, sub), sDoc.id)
                                });
                            });
                        });
                        deletePromises.push(deleteDoc(taskDocRef));
                    });
                    await Promise.all(deletePromises);

                    await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/boards`, currentBoardId));

                    showMessage("Board and all its tasks deleted successfully!", 'success');
                    currentBoardId = null;
                } catch (error) {
                    console.error("Error deleting board:", error);
                    showMessage("Error deleting board: " + error.message, 'error');
                }
            });
        };

        /**
         * Handles generating and displaying a shareable link for the current board.
         */
        const handleShareBoard = () => {
            if (!currentBoardId) {
                showMessage("Please select a board to share.", 'error');
                return;
            }
            // Construct a simple shareable URL. This is read-only for this client-side demo.
            const shareableLink = `${window.location.origin}${window.location.pathname}?ownerId=${userId}&boardId=${currentBoardId}`;
            shareableLinkInput.value = shareableLink;
            shareBoardModal.classList.add('show');
        };

        /**
         * Handles copying the shareable link to the clipboard.
         */
        const copyShareLink = () => {
            shareableLinkInput.select();
            document.execCommand('copy'); // Fallback for navigator.clipboard.writeText
            showMessage("Link copied to clipboard!", 'success');
        };

        // --- Column Management Functions ---

        /**
         * Handles adding a new column to the current board.
         */
        const handleAddColumn = async () => {
            const columnName = newColumnNameInput.value.trim();
            if (!columnName) {
                showMessage("Please enter a column name.", 'error');
                return;
            }
            if (!currentBoardId || !isAuthReady) {
                showMessage("Please select a board.", 'error');
                return;
            }

            const newColumnId = columnName.toLowerCase().replace(/\s/g, '-'); // Simple ID generation
            // Ensure unique ID, though Firestore doc ID is used for uniqueness
            if (currentBoardColumns.some(col => col.id === newColumnId)) {
                showMessage("A column with this name already exists. Please choose a different name.", 'error');
                return;
            }

            const newOrder = currentBoardColumns.length > 0 ? Math.max(...currentBoardColumns.map(c => c.order)) + 1 : 0;

            const newColumn = { id: newColumnId, name: columnName, order: newOrder };
            const updatedColumns = [...currentBoardColumns, newColumn].sort((a, b) => a.order - b.order);

            try {
                const boardRef = doc(db, `artifacts/${appId}/users/${userId}/boards`, currentBoardId);
                await updateDoc(boardRef, { columns: updatedColumns });
                showMessage(`Column "${columnName}" added successfully!`, 'success');
                addColumnModal.classList.remove('show');
                newColumnNameInput.value = '';
            } catch (error) {
                console.error("Error adding column:", error);
                showMessage("Error adding column: " + error.message, 'error');
            }
        };

        /**
         * Populates the select dropdowns in rename/delete column modals.
         */
        const populateColumnSelects = () => {
            selectColumnToRename.innerHTML = '';
            selectColumnToDelete.innerHTML = '';

            currentBoardColumns.forEach(column => {
                const optionRename = document.createElement('option');
                optionRename.value = column.id;
                optionRename.textContent = column.name;
                selectColumnToRename.appendChild(optionRename);

                const optionDelete = document.createElement('option');
                optionDelete.value = column.id;
                optionDelete.textContent = column.name;
                selectColumnToDelete.appendChild(optionDelete);
            });

            if (currentBoardColumns.length > 0) {
                renameColumnNameInput.value = currentBoardColumns[0].name;
            }
        };

        /**
         * Handles renaming a column.
         */
        const handleRenameColumn = async () => {
            const columnIdToRename = selectColumnToRename.value;
            const newColumnName = renameColumnNameInput.value.trim();

            if (!columnIdToRename || !newColumnName) {
                showMessage("Please select a column and enter a new name.", 'error');
                return;
            }
            if (!currentBoardId || !isAuthReady) {
                showMessage("Please select a board.", 'error');
                return;
            }

            const updatedColumns = currentBoardColumns.map(col =>
                col.id === columnIdToRename ? { ...col, name: newColumnName } : col
            );

            try {
                const boardRef = doc(db, `artifacts/${appId}/users/${userId}/boards`, currentBoardId);
                await updateDoc(boardRef, { columns: updatedColumns });
                showMessage(`Column renamed to "${newColumnName}" successfully!`, 'success');
                renameColumnModal.classList.remove('show');
            } catch (error) {
                console.error("Error renaming column:", error);
                showMessage("Error renaming column: " + error.message, 'error');
            }
        };

        /**
         * Handles deleting a column.
         */
        const handleDeleteColumn = async () => {
            const columnIdToDelete = selectColumnToDelete.value;

            if (!columnIdToDelete) {
                showMessage("Please select a column to delete.", 'error');
                return;
            }
            if (!currentBoardId || !isAuthReady) {
                showMessage("Please select a board.", 'error');
                return;
            }
            if (currentBoardColumns.length <= 1) {
                showMessage("Cannot delete the last column on the board.", 'error');
                return;
            }
            const backlogColumn = currentBoardColumns.find(col => col.id === 'backlog');
            if (columnIdToDelete === 'backlog' && currentBoardColumns.length > 1) {
                showMessage("Cannot delete the 'Backlog' column.", 'error');
                return;
            }

            showConfirmationModal(`Are you sure you want to delete column "${currentBoardColumns.find(c => c.id === columnIdToDelete)?.name}"? All tasks in it will be moved to the "Backlog" column.`, async (confirmed) => {
                if (!confirmed) {
                    return;
                }

                try {
                    const updatedColumns = currentBoardColumns.filter(col => col.id !== columnIdToDelete);
                    const boardRef = doc(db, `artifacts/${appId}/users/${userId}/boards`, currentBoardId);
                    await updateDoc(boardRef, { columns: updatedColumns });

                    // Move tasks from deleted column to 'backlog'
                    const tasksToMoveQuery = query(tasksCollectionRef, where('status', '==', columnIdToDelete));
                    const tasksSnapshot = await getDocs(tasksToMoveQuery);
                    const batch = writeBatch(db);

                    tasksSnapshot.forEach(taskDoc => {
                        const taskRef = doc(tasksCollectionRef, taskDoc.id);
                        batch.update(taskRef, { status: 'backlog' });
                    });
                    await batch.commit();

                    showMessage(`Column "${currentBoardColumns.find(c => c.id === columnIdToDelete)?.name}" deleted successfully and tasks moved.`, 'success');
                    deleteColumnModal.classList.remove('show');
                } catch (error) {
                    console.error("Error deleting column:", error);
                    showMessage("Error deleting column: " + error.message, 'error');
                }
            });
        };


        // --- Task Management Functions ---

        /**
         * Clears all task cards from the Kanban columns and shows empty state if needed.
         */
        const clearTasksFromUI = () => {
            kanbanBoard.querySelectorAll('.kanban-column').forEach(column => {
                const columnCardsContainer = column.querySelector('.column-cards');
                if (columnCardsContainer) {
                    columnCardsContainer.innerHTML = `
                        <div class="empty-state hidden">
                            <i class="fas fa-clipboard-list"></i>
                            <p>No tasks here yet!</p>
                        </div>
                    `;
                }
            });
            // Ensure the add column placeholder is present
            if (!kanbanBoard.contains(addColumnPlaceholder)) {
                kanbanBoard.appendChild(addColumnPlaceholder);
            }
            currentBoardColumns.forEach(column => updateEmptyState(column.id));
        };

        /**
         * Renders a task card in the appropriate Kanban column.
         * @param {string} taskId - The ID of the task document.
         * @param {object} taskData - The data of the task (text, status, etc.).
         */
        const renderTask = (taskId, taskData) => {
            const existingCard = document.getElementById(`task-${taskId}`);
            if (existingCard) {
                existingCard.remove();
            }

            const taskCard = document.createElement('div');
            taskCard.id = `task-${taskId}`;
            taskCard.className = `task-card ${taskData.status === 'done' ? 'done' : ''}`;
            taskCard.draggable = true;
            taskCard.dataset.taskId = taskId;
            taskCard.dataset.taskStatus = taskData.status;

            // Priority Dot - Hidden in main card view as per Trello style
            const priorityDot = document.createElement('div');
            priorityDot.className = `priority-dot ${taskData.priority && taskData.priority !== 'no-priority' ? 'priority-' + taskData.priority : 'hidden'}`;
            taskCard.appendChild(priorityDot);

            const taskTextContainer = document.createElement('div');
            taskTextContainer.className = 'flex-grow mr-4 pt-2';
            taskTextContainer.innerHTML = `
                <span class="task-text font-semibold text-lg">${taskData.text}</span>
                ${taskData.dueDate ? `<div class="text-xs text-gray-500 dark:text-gray-400 mt-1"><i class="fas fa-calendar-alt"></i> ${taskData.dueDate}</div>` : ''}
                ${taskData.assignedTo ? `<div class="text-xs text-gray-500 dark:text-gray-400"><i class="fas fa-user-circle"></i> ${taskData.assignedTo}</div>` : ''}
            `;
            taskCard.appendChild(taskTextContainer);


            const deleteButton = document.createElement('button');
            deleteButton.className = 'delete-button';
            deleteButton.innerHTML = '<i class="fas fa-trash-alt"></i>';
            deleteButton.onclick = (e) => {
                e.stopPropagation();
                deleteTask(taskId);
            };
            taskCard.appendChild(deleteButton);

            taskCard.addEventListener('click', () => openTaskDetailModal(taskId));
            taskCard.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', taskId);
                e.currentTarget.classList.add('dragging');
            });
            taskCard.addEventListener('dragend', (e) => {
                e.currentTarget.classList.remove('dragging');
            });

            const targetColumn = document.getElementById(`${taskData.status}-column`);
            if (targetColumn && shouldTaskBeVisible(taskData)) {
                const columnCardsContainer = targetColumn.querySelector('.column-cards');
                if (columnCardsContainer) {
                    columnCardsContainer.appendChild(taskCard);
                }
            } else if (taskCard) {
                taskCard.style.display = 'none';
            }
            updateEmptyState(taskData.status);
        };

        /**
         * Updates the visibility of empty state messages in columns.
         * @param {string} columnId - The ID of the column to check.
         */
        const updateEmptyState = (columnId) => {
            const columnElement = document.getElementById(`${columnId}-column`);
            if (!columnElement) return;

            const columnCardsContainer = columnElement.querySelector('.column-cards');
            if (!columnCardsContainer) return;

            const tasksInColumn = columnCardsContainer.querySelectorAll('.task-card:not([style*="display: none"])');
            const emptyStateDiv = columnCardsContainer.querySelector('.empty-state');
            if (emptyStateDiv) {
                if (tasksInColumn.length === 0) {
                    emptyStateDiv.classList.remove('hidden');
                } else {
                    emptyStateDiv.classList.add('hidden');
                }
            }
        };


        /**
         * Adds a new task to Firestore from a specific column.
         * @param {string} taskText - The text of the new task.
         * @param {string} columnId - The ID of the column to add the task to.
         * @param {HTMLInputElement} inputElement - The input field element.
         * @param {HTMLElement} showButtonElement - The "Add a card" button element.
         * @param {HTMLElement} inputContainerElement - The input container element.
         */
        const handleAddCardInColumn = async (taskText, columnId, inputElement, showButtonElement, inputContainerElement) => {
            if (taskText.trim() === '') {
                return;
            }

            if (!isAuthReady || !tasksCollectionRef || !currentBoardId) {
                console.warn("Firebase authentication not ready, no board selected, or collection ref not set. Cannot add task.");
                showMessage("Please log in and select a board to add tasks.", 'error');
                return;
            }

            try {
                // Temporarily disable input and show loading if needed (optional)
                inputElement.disabled = true;
                // showButtonElement.innerHTML = '<span class="loading-spinner"></span> Add Card'; // If you want loading per button

                await addDoc(tasksCollectionRef, {
                    text: taskText.trim(),
                    status: columnId,
                    description: '',
                    dueDate: '',
                    assignedTo: '',
                    priority: 'no-priority',
                    tags: [],
                    createdAt: serverTimestamp(),
                    lastActivityAt: serverTimestamp()
                });
                inputElement.value = '';
                inputContainerElement.classList.add('hidden');
                showButtonElement.classList.remove('hidden');
                showMessage("Task added successfully!", 'success');
            } catch (error) {
                console.error("Error adding task:", error);
                showMessage("Error adding task: " + error.message, 'error');
            } finally {
                inputElement.disabled = false;
                // showButtonElement.innerHTML = '<i class="fas fa-plus"></i> Add Card';
            }
        };


        /**
         * Deletes a task from Firestore.
         * @param {string} taskId - The ID of the task to delete.
         */
        const deleteTask = async (taskId) => {
            if (!isAuthReady || !tasksCollectionRef || !currentBoardId) {
                console.warn("Firebase authentication not ready, no board selected, or collection ref not set. Cannot delete task.");
                return;
            }
            showConfirmationModal("Are you sure you want to delete this task?", async (confirmed) => {
                if (!confirmed) {
                    return;
                }
                try {
                    const taskDocRef = doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks`, taskId);

                    const subcollections = ['checklists', 'comments', 'activities'];
                    for (const sub of subcollections) {
                        const subCollectionRef = collection(taskDocRef, sub);
                        const subSnapshot = await getDocs(subCollectionRef);
                        const deletePromises = [];
                        subSnapshot.forEach(subDoc => {
                            deletePromises.push(deleteDoc(doc(subCollectionRef, subDoc.id)));
                        });
                        await Promise.all(deletePromises);
                    }

                    await deleteDoc(taskDocRef);
                    console.log(`Task ${taskId} deleted.`);
                    showMessage("Task deleted successfully.", 'info');
                    closeTaskDetailModal();
                } catch (error) {
                    console.error("Error deleting task:", error);
                    showMessage("Error deleting task: " + error.message, 'error');
                }
            });
        };

        /**
         * Sets up a real-time listener for tasks from Firestore.
         */
        const setupTaskListener = () => {
            if (!isAuthReady || !tasksCollectionRef || !currentBoardId) {
                console.warn("Firebase authentication not ready, no board selected, or collection ref not set, delaying task listener setup.");
                clearTasksFromUI();
                if (unsubscribeFromTasks) { unsubscribeFromTasks(); unsubscribeFromTasks = null; }
                return;
            }

            if (unsubscribeFromTasks) {
                unsubscribeFromTasks();
            }

            clearTasksFromUI(); // Clear UI before re-rendering for dynamic columns

            const q = query(tasksCollectionRef, orderBy('createdAt'));

            unsubscribeFromTasks = onSnapshot(q, (querySnapshot) => {
                // Remove only tasks that are no longer in the snapshot
                const existingTaskIds = new Set();
                querySnapshot.forEach(doc => existingTaskIds.add(doc.id));
                kanbanBoard.querySelectorAll('.task-card').forEach(card => {
                    if (!existingTaskIds.has(card.dataset.taskId)) {
                        card.remove();
                    }
                });

                allTasksData = []; // Clear and repopulate allTasksData
                querySnapshot.forEach((doc) => {
                    const task = { id: doc.id, ...doc.data() };
                    allTasksData.push(task);
                    renderTask(task.id, task); // Re-render or add tasks
                });
                console.log("Tasks updated from Firestore for board:", currentBoardId);
                applyFilters(); // Re-apply filters after tasks are rendered/updated
                currentBoardColumns.forEach(column => updateEmptyState(column.id)); // Update empty states for all columns
            }, (error) => {
                console.error("Error fetching tasks:", error);
                showMessage("Error loading tasks: " + error.message, 'error');
            });
        };

        // --- Drag and Drop Functions ---
        const addDragAndDropListeners = () => {
            // Get all dynamically created columns
            const columns = kanbanBoard.querySelectorAll('.kanban-column');
            columns.forEach(column => {
                column.removeEventListener('dragover', handleDragOver);
                column.removeEventListener('dragleave', handleDragLeave);
                column.removeEventListener('drop', handleDrop);
                column.addEventListener('dragover', handleDragOver);
                column.addEventListener('dragleave', handleDragLeave);
                column.addEventListener('drop', handleDrop);
            });
        };

        const handleDragOver = (e) => {
            e.preventDefault();
            const draggingCard = document.querySelector('.task-card.dragging');
            if (draggingCard && e.target.closest('.kanban-column')) { // Check if dragging over a column or its child
                e.target.closest('.kanban-column').style.backgroundColor = document.documentElement.classList.contains('dark') ? 'var(--drag-over-color-dark)' : 'var(--drag-over-color-light)';
            }
        };

        const handleDragLeave = (e) => {
            if (e.target.closest('.kanban-column')) {
                e.target.closest('.kanban-column').style.backgroundColor = '';
            }
        };

        const handleDrop = async (e) => {
            e.preventDefault();
            const droppedColumn = e.target.closest('.kanban-column');
            if (droppedColumn) {
                droppedColumn.style.backgroundColor = '';
            }

            const taskId = e.dataTransfer.getData('text/plain');
            const newStatus = droppedColumn ? droppedColumn.dataset.status : null;

            if (!taskId || !newStatus) {
                console.warn("Invalid drop operation: Task ID or new status missing.");
                return;
            }

            if (!isAuthReady || !tasksCollectionRef || !currentBoardId) {
                console.warn("Firebase authentication not ready, no board selected, or collection ref not set. Cannot update task status.");
                showMessage("Please log in and select a board to update tasks.", 'error');
                return;
            }

            try {
                const taskRef = doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks`, taskId);
                const oldTaskSnap = await getDoc(taskRef);
                const oldStatus = oldTaskSnap.exists() ? oldTaskSnap.data().status : 'unknown';

                await updateDoc(taskRef, {
                    status: newStatus,
                    lastActivityAt: serverTimestamp()
                });
                console.log(`Task ${taskId} moved to ${newStatus} on board ${currentBoardId}.`);

                if (oldStatus !== newStatus) {
                    logActivity(taskId, 'status_change', `Task moved from "${oldStatus}" to "${newStatus}".`);
                }

                if (newStatus === 'done') {
                    startConfetti();
                    showMessage("Congratulations! Task completed!", 'success');
                }
                updateEmptyState(oldStatus);
                updateEmptyState(newStatus);
            } catch (error) {
                console.error("Error updating task status:", error);
                showMessage("Error updating task status: " + error.message, 'error');
            }
        };

        // --- Task Detail Modal Functions ---

        /**
         * Opens the task detail modal and loads task data.
         * @param {string} taskId - The ID of the task to open.
         */
        const openTaskDetailModal = async (taskId) => {
            if (!isAuthReady || !currentBoardId) {
                showMessage("Please log in and select a board to view task details.", 'error');
                return;
            }

            currentTaskId = taskId;
            taskDetailModal.classList.add('show');

            taskDetailTitleInput.value = '';
            taskDetailDescriptionInput.value = '';
            taskDetailDueDateInput.value = '';
            taskDetailAssignedToInput.value = '';
            taskDetailPrioritySelect.value = 'no-priority';
            checklistsContainer.innerHTML = '';
            commentsContainer.innerHTML = '';
            activityLogContainer.innerHTML = '';
            newCommentInput.value = '';

            unsubscribeFromTaskDetails.forEach(unsub => unsub());
            unsubscribeFromTaskDetails = [];

            const taskRef = doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks`, taskId);

            const checklistsRef = collection(taskRef, 'checklists');
            const commentsRef = collection(taskRef, 'comments');
            const activitiesRef = collection(taskRef, 'activities');

            unsubscribeFromTaskDetails.push(onSnapshot(taskRef, (docSnap) => {
                if (docSnap.exists()) {
                    const taskData = docSnap.data();
                    taskDetailTitleInput.value = taskData.text || '';
                    taskDetailDescriptionInput.value = taskData.description || '';
                    taskDetailDueDateInput.value = taskData.dueDate || '';
                    taskDetailAssignedToInput.value = taskData.assignedTo || '';
                    taskDetailPrioritySelect.value = taskData.priority || 'no-priority';
                } else {
                    console.log("Task does not exist, closing modal.");
                    closeTaskDetailModal();
                }
            }, (error) => {
                console.error("Error fetching task details:", error);
                showMessage("Error loading task details: " + error.message, 'error');
            }));

            unsubscribeFromTaskDetails.push(onSnapshot(query(checklistsRef, orderBy('createdAt')), (snapshot) => {
                checklistsContainer.innerHTML = '';
                snapshot.forEach(checklistDoc => {
                    renderChecklist(checklistDoc.id, checklistDoc.data());
                });
            }, (error) => {
                console.error("Error fetching checklists:", error);
            }));

            unsubscribeFromTaskDetails.push(onSnapshot(query(commentsRef, orderBy('createdAt')), (snapshot) => {
                commentsContainer.innerHTML = '';
                snapshot.forEach(commentDoc => {
                    renderComment(commentDoc.id, commentDoc.data());
                });
            }, (error) => {
                console.error("Error fetching comments:", error);
            }));

            unsubscribeFromTaskDetails.push(onSnapshot(query(activitiesRef, orderBy('createdAt')), (snapshot) => {
                activityLogContainer.innerHTML = '';
                snapshot.forEach(activityDoc => {
                    renderActivity(activityDoc.data());
                });
                activityLogContainer.scrollTop = activityLogContainer.scrollHeight;
            }, (error) => {
                console.error("Error fetching activities:", error);
            }));
        };

        /**
         * Closes the task detail modal and cleans up listeners.
         */
        const closeTaskDetailModal = () => {
            taskDetailModal.classList.remove('show');
            currentTaskId = null;
            unsubscribeFromTaskDetails.forEach(unsub => unsub());
            unsubscribeFromTaskDetails = [];
        };

        /**
         * Updates a field in the current task document.
         * @param {string} fieldName - The name of the field to update.
         * @param {any} value - The new value for the field.
         */
        const updateTaskField = async (fieldName, value) => {
            if (!currentTaskId || !currentBoardId || !isAuthReady) return;
            const taskRef = doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks`, currentTaskId);
            try {
                const updates = { [fieldName]: value, lastActivityAt: serverTimestamp() };
                await updateDoc(taskRef, updates);
                console.log(`Task ${currentTaskId} field ${fieldName} updated.`);
                logActivity(currentTaskId, 'field_update', `Field "${fieldName}" updated to "${value}".`);
            } catch (error) {
                console.error(`Error updating task field ${fieldName}:`, error);
                showMessage(`Error updating ${fieldName}: ` + error.message, 'error');
            }
        };

        // --- Checklist Functions ---
        const renderChecklist = (checklistId, checklistData) => {
            const checklistDiv = document.createElement('div');
            checklistDiv.className = 'bg-gray-50 dark:bg-gray-700 p-3 rounded-lg mb-4 border border-gray-200 dark:border-gray-600';
            checklistDiv.dataset.checklistId = checklistId;

            const checklistHeader = document.createElement('div');
            checklistHeader.className = 'flex justify-between items-center mb-2';
            checklistHeader.innerHTML = `
                <h4 class="font-semibold text-gray-700 dark:text-gray-200">${checklistData.title}</h4>
                <div class="flex items-center gap-2">
                    <span class="text-sm text-gray-600 dark:text-gray-300">${checklistData.items.filter(item => item.completed).length}/${checklistData.items.length}</span>
                    <button class="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-600 text-sm delete-checklist-button" data-checklist-id="${checklistId}"><i class="fas fa-trash-alt"></i></button>
                </div>
            `;
            checklistDiv.appendChild(checklistHeader);

            const progressBarContainer = document.createElement('div');
            progressBarContainer.className = 'progress-bar-container';
            const progressBar = document.createElement('div');
            progressBar.className = 'progress-bar';
            const completedItems = checklistData.items.filter(item => item.completed).length;
            const totalItems = checklistData.items.length;
            const progress = totalItems > 0 ? (completedItems / totalItems) * 100 : 0;
            progressBar.style.width = `${progress}%`;
            progressBarContainer.appendChild(progressBar);
            checklistDiv.appendChild(progressBarContainer);

            const itemsList = document.createElement('div');
            itemsList.className = 'flex flex-col gap-2';
            checklistData.items.forEach((item, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'checklist-item';
                itemDiv.innerHTML = `
                    <input type="checkbox" ${item.completed ? 'checked' : ''} class="item-checkbox" data-index="${index}">
                    <span class="item-text ${item.completed ? 'completed' : ''}">${item.text}</span>
                    <button class="text-red-400 hover:text-red-600 text-xs delete-checklist-item-button" data-index="${index}"><i class="fas fa-times"></i></button>
                `;
                itemsList.appendChild(itemDiv);
            });
            checklistDiv.appendChild(itemsList);

            const addChecklistItemInput = document.createElement('input');
            addChecklistItemInput.type = 'text';
            addChecklistItemInput.placeholder = 'Add an item to the checklist...';
            addChecklistItemInput.className = 'input-field mt-3';
            addChecklistItemInput.addEventListener('keypress', async (e) => {
                if (e.key === 'Enter' && addChecklistItemInput.value.trim() !== '') {
                    await addChecklistItem(currentTaskId, checklistId, addChecklistItemInput.value.trim());
                    addChecklistItemInput.value = '';
                }
            });
            checklistDiv.appendChild(addChecklistItemInput);

            checklistsContainer.appendChild(checklistDiv);

            checklistDiv.querySelectorAll('.item-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', async (e) => {
                    const index = parseInt(e.target.dataset.index);
                    await toggleChecklistItem(currentTaskId, checklistId, index, e.target.checked);
                });
            });
            checklistDiv.querySelectorAll('.delete-checklist-item-button').forEach(button => {
                button.addEventListener('click', async (e) => {
                    const index = parseInt(e.currentTarget.dataset.index);
                    await deleteChecklistItem(currentTaskId, checklistId, index);
                });
            });
            checklistDiv.querySelector('.delete-checklist-button').addEventListener('click', async (e) => {
                const id = e.currentTarget.dataset.checklistId;
                await deleteChecklist(currentTaskId, id);
            });
        };

        const handleAddChecklist = async () => {
            const checklistTitle = prompt("Enter the title for the new checklist:");
            if (!checklistTitle || checklistTitle.trim() === '') {
                showMessage("Checklist title cannot be empty.", 'error');
                return;
            }

            if (!currentTaskId || !currentBoardId || !isAuthReady) {
                showMessage("Please select a task and board.", 'error');
                return;
            }

            try {
                const checklistsRef = collection(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks/${currentTaskId}/checklists`);
                await addDoc(checklistsRef, {
                    title: checklistTitle.trim(),
                    items: [],
                    createdAt: serverTimestamp()
                });
                showMessage("Checklist added successfully!", 'success');
                logActivity(currentTaskId, 'checklist_added', `Checklist added: "${checklistTitle.trim()}"`);
                await updateDoc(doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks`, currentTaskId), {
                    lastActivityAt: serverTimestamp()
                });
            } catch (error) {
                console.error("Error adding checklist:", error);
                showMessage("Error adding checklist: " + error.message, 'error');
            }
        };

        const addChecklistItem = async (taskId, checklistId, itemText) => {
            if (!taskId || !checklistId || !itemText || !isAuthReady) return;
            try {
                const checklistRef = doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks/${taskId}/checklists`, checklistId);
                await updateDoc(checklistRef, {
                    items: arrayUnion({ text: itemText, completed: false })
                });
                logActivity(taskId, 'checklist_item_added', `Added item to checklist "${checklistId}": "${itemText}"`);
                await updateDoc(doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks`, currentTaskId), {
                    lastActivityAt: serverTimestamp()
                });
            } catch (error) {
                console.error("Error adding checklist item:", error);
                showMessage("Error adding checklist item: " + error.message, 'error');
            }
        };

        const toggleChecklistItem = async (taskId, checklistId, itemIndex, completed) => {
            if (!taskId || !checklistId || !isAuthReady) return;
            try {
                const checklistRef = doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks/${taskId}/checklists`, checklistId);
                const checklistSnap = await getDoc(checklistRef);
                if (checklistSnap.exists()) {
                    const checklistData = checklistSnap.data();
                    const items = [...checklistData.items];
                    if (items[itemIndex]) {
                        items[itemIndex].completed = completed;
                        await updateDoc(checklistRef, { items: items });
                        logActivity(taskId, 'checklist_item_toggled', `${completed ? 'Completed' : 'Uncompleted'} item in checklist "${checklistId}": "${items[itemIndex].text}"`);
                        
                        // Check if all checklist items are completed
                        const allItemsCompleted = items.every(item => item.completed);
                        if (allItemsCompleted) {
                            const taskRef = doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks`, taskId);
                            const taskSnap = await getDoc(taskRef);
                            if (taskSnap.exists() && taskSnap.data().status !== 'done') {
                                await updateDoc(taskRef, { status: 'done', lastActivityAt: serverTimestamp() });
                                showMessage("Congratulations! Task completed (via checklist completion)!", 'success');
                                startConfetti();
                                logActivity(taskId, 'status_change_auto', 'Task automatically moved to "Done" (all checklist items completed).');
                            }
                        }

                        await updateDoc(doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks`, currentTaskId), {
                            lastActivityAt: serverTimestamp()
                        });
                    }
                }
            } catch (error) {
                console.error("Error toggling checklist item:", error);
                showMessage("Error updating checklist item: " + error.message, 'error');
            }
        };

        const deleteChecklistItem = async (taskId, checklistId, itemIndex) => {
            if (!taskId || !checklistId || !isAuthReady) return;
            try {
                const checklistRef = doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks/${taskId}/checklists`, checklistId);
                const checklistSnap = await getDoc(checklistRef);
                if (checklistSnap.exists()) {
                    const checklistData = checklistSnap.data();
                    const items = [...checklistData.items];
                    const [deletedItem] = items.splice(itemIndex, 1);
                    await updateDoc(checklistRef, { items: items });
                    showMessage("Checklist item deleted.", 'info');
                    if (deletedItem) {
                        logActivity(taskId, 'checklist_item_deleted', `Deleted item from checklist "${checklistId}": "${deletedItem.text}"`);
                        await updateDoc(doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks`, currentTaskId), {
                            lastActivityAt: serverTimestamp()
                        });
                    }
                }
            } catch (error) {
                console.error("Error deleting checklist item:", error);
                showMessage("Error deleting checklist item: " + error.message, 'error');
            }
        };

        const deleteChecklist = async (taskId, checklistId) => {
            if (!taskId || !checklistId || !isAuthReady) return;
            showConfirmationModal("Are you sure you want to delete this checklist?", async (confirmed) => {
                if (!confirmed) {
                    return;
                }
                try {
                    const checklistRef = doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks/${taskId}/checklists`, checklistId);
                    await deleteDoc(checklistRef);
                    showMessage("Checklist deleted successfully.", 'info');
                    logActivity(taskId, 'checklist_deleted', `Checklist deleted: "${checklistId}"`);
                    await updateDoc(doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks`, currentTaskId), {
                        lastActivityAt: serverTimestamp()
                    });
                } catch (error) {
                    console.error("Error deleting checklist:", error);
                    showMessage("Error deleting checklist: " + error.message, 'error');
                }
            });
        };

        // --- Comment Functions ---
        const renderComment = (commentId, commentData) => {
            const commentDiv = document.createElement('div');
            commentDiv.className = 'comment-item';
            commentDiv.dataset.commentId = commentId;

            const authorSpan = document.createElement('span');
            authorSpan.className = 'comment-author';
            authorSpan.textContent = commentData.authorId === userId ? userDisplayName : (commentData.authorDisplayName || commentData.authorId.substring(0, 8) + "...");

            const textP = document.createElement('p');
            textP.textContent = commentData.text;

            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'comment-timestamp';
            if (commentData.createdAt && commentData.createdAt.toDate) {
                timestampSpan.textContent = commentData.createdAt.toDate().toLocaleString();
            } else {
                timestampSpan.textContent = 'Now';
            }

            const deleteButton = document.createElement('button');
            deleteButton.className = 'delete-button absolute top-2 right-2 text-xs';
            deleteButton.innerHTML = '<i class="fas fa-times"></i>';
            deleteButton.onclick = async () => {
                await deleteComment(currentTaskId, commentId);
            };

            commentDiv.appendChild(authorSpan);
            commentDiv.appendChild(textP);
            commentDiv.appendChild(timestampSpan);
            if (commentData.authorId === userId) {
                commentDiv.appendChild(deleteButton);
            }

            commentsContainer.appendChild(commentDiv);
        };

        const handleAddComment = async () => {
            const commentText = newCommentInput.value.trim();
            if (!commentText) {
                showMessage("Please write a comment.", 'error');
                return;
            }

            if (!currentTaskId || !currentBoardId || !isAuthReady) {
                showMessage("Please select a task and board.", 'error');
                return;
            }

            try {
                const commentsRef = collection(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks/${currentTaskId}/comments`);
                await addDoc(commentsRef, {
                    text: commentText,
                    authorId: userId,
                    authorDisplayName: userDisplayName,
                    createdAt: serverTimestamp()
                });
                newCommentInput.value = '';
                showMessage("Comment added successfully!", 'success');

                const mentionRegex = /@(\w+)/g;
                let match;
                let mentionedUsers = [];
                while ((match = mentionRegex.exec(commentText)) !== null) {
                    const mentionedIdOrName = match[1];
                    mentionedUsers.push(mentionedIdOrName);
                }

                let activityDescription = `Comment added: "${commentText.substring(0, 50)}..."`;
                if (mentionedUsers.length > 0) {
                    activityDescription += ` (Mentioned: ${mentionedUsers.join(', ')})`;
                }
                logActivity(currentTaskId, 'comment_added', activityDescription);

                await updateDoc(doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks`, currentTaskId), {
                    lastActivityAt: serverTimestamp()
                });
            } catch (error) {
                console.error("Error adding comment:", error);
                showMessage("Error adding comment: " + error.message, 'error');
            }
        };

        const deleteComment = async (taskId, commentId) => {
            if (!taskId || !commentId || !isAuthReady) return;
            showConfirmationModal("Are you sure you want to delete this comment?", async (confirmed) => {
                if (!confirmed) {
                    return;
                }
                try {
                    const commentRef = doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks/${taskId}/comments`, commentId);
                    await deleteDoc(commentRef);
                    showMessage("Comment deleted successfully.", 'info');
                    logActivity(taskId, 'comment_deleted', `Comment deleted.`);
                    await updateDoc(doc(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks`, currentTaskId), {
                        lastActivityAt: serverTimestamp()
                    });
                } catch (error) {
                    console.error("Error deleting comment:", error);
                    showMessage("Error deleting comment: " + error.message, 'error');
                }
            });
        };

        // --- Activity Log Functions ---

        const renderActivity = (activityData) => {
            const activityDiv = document.createElement('div');
            activityDiv.className = 'activity-item';

            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'activity-timestamp';
            if (activityData.createdAt && activityData.createdAt.toDate) {
                timestampSpan.textContent = activityData.createdAt.toDate().toLocaleString();
            } else {
                timestampSpan.textContent = 'Now';
            }

            activityDiv.textContent = activityData.description;
            activityDiv.appendChild(timestampSpan);
            activityLogContainer.appendChild(activityDiv);
        };

        const logActivity = async (taskId, type, description) => {
            if (!taskId || !isAuthReady || !currentBoardId) return;
            try {
                const activitiesRef = collection(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks/${taskId}/activities`);
                await addDoc(activitiesRef, {
                    type: type,
                    description: description,
                    userId: userId,
                    createdAt: serverTimestamp()
                });
                const userDocRef = doc(usersCollectionRef, userId);
                await updateDoc(userDocRef, { lastActivity: serverTimestamp() }, { merge: true });
            } catch (error) {
                console.error("Error logging activity:", error);
            }
        };

        // --- Confetti Animation Functions ---
        const resizeConfettiCanvas = () => {
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
        };

        class ConfettiParticle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 8 + 5;
                this.color = color;
                this.velocity = {
                    x: (Math.random() - 0.5) * 10,
                    y: (Math.random() - 0.5) * 10 - 5
                };
                this.gravity = 0.3;
                this.rotation = Math.random() * 360;
                this.rotationSpeed = Math.random() * 10 - 5;
                this.alpha = 1;
                this.decay = 0.01;
            }

            update() {
                this.velocity.y += this.gravity;
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.rotation += this.rotationSpeed;
                this.alpha -= this.decay;
            }

            draw() {
                confettiCtx.save();
                confettiCtx.translate(this.x, this.y);
                confettiCtx.rotate(this.rotation * Math.PI / 180);
                confettiCtx.globalAlpha = this.alpha;
                confettiCtx.fillStyle = this.color;
                confettiCtx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                confettiCtx.restore();
            }
        }

        const createConfetti = (count, x, y) => {
            const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4CAF50', '#8BC34A', '#CDDC39', '#FFEB3B', '#FFC107', '#FF9800', '#FF5722'];
            for (let i = 0; i < count; i++) {
                const color = colors[Math.floor(Math.random() * colors.length)];
                confettiParticles.push(new ConfettiParticle(x, y, color));
            }
        };

        const animateConfetti = () => {
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

            for (let i = confettiParticles.length - 1; i >= 0; i--) {
                const p = confettiParticles[i];
                p.update();
                p.draw();

                if (p.alpha <= 0 || p.y > confettiCanvas.height + p.size) {
                    confettiParticles.splice(i, 1);
                }
            }

            if (confettiParticles.length > 0) {
                animationFrameId = requestAnimationFrame(animateConfetti);
            } else {
                confettiCanvas.style.display = 'none';
                animationFrameId = null;
            }
        };

        const startConfetti = () => {
            resizeConfettiCanvas();
            confettiCanvas.style.display = 'block';

            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;

            createConfetti(100, centerX, centerY);

            if (!animationFrameId) {
                animationFrameId = requestAnimationFrame(animateConfetti);
            }

            setTimeout(() => {
                // Allow current particles to finish, but don't create new ones
            }, 3000);
        };

        // --- Filtering and Search Functions ---

        /**
         * Checks if a task should be visible based on current filter/search criteria.
         * @param {object} task - The task data.
         * @returns {boolean} - True if the task should be visible, false otherwise.
         */
        const shouldTaskBeVisible = (task) => {
            const searchText = window.innerWidth >= 768 ? taskSearchInput.value.toLowerCase().trim() : taskSearchInputMobile.value.toLowerCase().trim();
            const filterStatus = filterStatusSelect.value;
            const filterAssignedTo = filterAssignedToInput.value.toLowerCase().trim();
            const filterDueDate = filterDueDateSelect.value;
            const filterPriority = filterPrioritySelect.value;

            // Search by text
            if (searchText && !(task.text && task.text.toLowerCase().includes(searchText)) && !(task.description && task.description.toLowerCase().includes(searchText))) {
                return false;
            }

            // Filter by status
            if (filterStatus !== 'all' && task.status !== filterStatus) {
                return false;
            }

            // Filter by assignedTo
            if (filterAssignedTo && !(task.assignedTo && task.assignedTo.toLowerCase().includes(filterAssignedTo))) {
                return false;
            }

            // Filter by due date
            if (filterDueDate !== 'all') {
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                const taskDueDate = task.dueDate ? new Date(task.dueDate) : null;
                if (taskDueDate) {
                    taskDueDate.setHours(0, 0, 0, 0);
                }

                if (filterDueDate === 'today') {
                    if (!taskDueDate || taskDueDate.getTime() !== today.getTime()) {
                        return false;
                    }
                } else if (filterDueDate === 'this-week') {
                    const weekEnd = new Date(today);
                    weekEnd.setDate(today.getDate() + 7);
                    if (!taskDueDate || taskDueDate.getTime() < today.getTime() || taskDueDate.getTime() > weekEnd.getTime()) {
                        return false;
                    }
                } else if (filterDueDate === 'overdue') {
                    if (!taskDueDate || taskDueDate.getTime() >= today.getTime() || task.status === 'done') {
                        return false;
                    }
                } else if (filterDueDate === 'no-date') {
                    if (taskDueDate) {
                        return false;
                    }
                }
            }

            // Filter by priority
            if (filterPriority !== 'all') {
                if (filterPriority === 'no-priority') {
                    if (task.priority && task.priority !== 'no-priority') {
                        return false;
                    }
                } else if (task.priority !== filterPriority) {
                    return false;
                }
            }

            return true;
        };

        /**
         * Applies the current filters and search query to the displayed tasks.
         */
        const applyFilters = () => {
            // Remove all task cards from columns to re-render based on filters
            kanbanBoard.querySelectorAll('.task-card').forEach(card => card.remove());

            const filteredTasks = allTasksData.filter(task => shouldTaskBeVisible(task));

            filteredTasks.forEach(task => {
                renderTask(task.id, task); // Re-render tasks based on visibility
            });

            // Update empty states for all columns after filtering
            currentBoardColumns.forEach(column => updateEmptyState(column.id));
        };

        // --- Notification Functions ---

        /**
         * Sets up a real-time listener for user notifications.
         */
        const setupNotificationListener = () => {
            if (!isAuthReady || !userId || !usersCollectionRef || !currentUserSettings.notificationsEnabled) {
                if (unsubscribeFromNotifications) {
                    unsubscribeFromNotifications();
                    unsubscribeFromNotifications = null;
                }
                notificationButton.style.display = 'none';
                return;
            } else {
                notificationButton.style.display = 'flex';
            }


            if (unsubscribeFromNotifications) {
                unsubscribeFromNotifications();
            }

            const notificationsRef = collection(db, `artifacts/${appId}/users/${userId}/notifications`);
            const q = query(notificationsRef, orderBy('createdAt', 'desc'));

            unsubscribeFromNotifications = onSnapshot(q, (querySnapshot) => {
                notificationsList.innerHTML = '';
                unreadNotificationsCount = 0;
                if (querySnapshot.empty) {
                    notificationsList.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-center py-4 text-sm">No notifications currently.</p>';
                }

                querySnapshot.forEach(doc => {
                    const notification = { id: doc.id, ...doc.data() };
                    renderNotification(notification);
                    if (!notification.isRead) {
                        unreadNotificationsCount++;
                    }
                });
                updateNotificationBadge();
            }, (error) => {
                console.error("Error fetching notifications:", error);
            });
        };

        /**
         * Renders a single notification item.
         * @param {object} notification - The notification data.
         */
        const renderNotification = (notification) => {
            const notificationItem = document.createElement('div');
            notificationItem.className = `notification-item ${notification.isRead ? '' : 'unread'} rounded-md my-1`;
            notificationItem.dataset.notificationId = notification.id;
            notificationItem.dataset.taskId = notification.taskId || '';

            notificationItem.innerHTML = `
                <p class="notification-item-message">${notification.message}</p>
                <span class="notification-item-timestamp">${notification.createdAt ? notification.createdAt.toDate().toLocaleString() : 'Now'}</span>
            `;

            notificationItem.addEventListener('click', async () => {
                if (notification.taskId) {
                    closeNotificationDropdown();
                    openTaskDetailModal(notification.taskId);
                }
                await markNotificationAsRead(notification.id);
            });

            notificationsList.appendChild(notificationItem);
        };

        /**
         * Updates the notification badge count.
         */
        const updateNotificationBadge = () => {
            if (unreadNotificationsCount > 0) {
                notificationBadge.textContent = unreadNotificationsCount;
                notificationBadge.classList.remove('hidden');
            } else {
                notificationBadge.classList.add('hidden');
            }
        };

        /**
         * Marks a specific notification as read.
         * @param {string} notificationId - The ID of the notification to mark as read.
         */
        const markNotificationAsRead = async (notificationId) => {
            if (!isAuthReady || !userId) return;
            try {
                const notificationRef = doc(db, `artifacts/${appId}/users/${userId}/notifications`, notificationId);
                await updateDoc(notificationRef, { isRead: true });
                console.log(`Notification ${notificationId} marked as read.`);
            } catch (error) {
                console.error("Error marking notification as read:", error);
            }
        };

        /**
         * Marks all unread notifications as read.
         */
        const markAllNotificationsAsRead = async () => {
            if (!isAuthReady || !userId) return;
            try {
                const notificationsRef = collection(db, `artifacts/${appId}/users/${userId}/notifications`);
                const q = query(notificationsRef, where("isRead", "==", false));
                const snapshot = await getDocs(q);

                const batch = writeBatch(db);
                snapshot.forEach(doc => {
                    batch.update(doc.ref, { isRead: true });
                });
                await batch.commit();
                showMessage("All notifications marked as read.", 'info');
            } catch (error) {
                console.error("Error marking all notifications as read:", error);
                showMessage("Failed to mark notifications as read.", 'error');
            }
        };


        const toggleNotificationDropdown = () => {
            notificationDropdown.classList.toggle('show');
        };

        const closeNotificationDropdown = () => {
            notificationDropdown.classList.remove('show');
        };

        // --- User Settings Functions ---

        /**
         * Sets up a real-time listener for current user settings.
         */
        const setupUserSettingsListener = () => {
            if (!isAuthReady || !userId || !usersCollectionRef) return;

            if (unsubscribeFromUserSettings) {
                unsubscribeFromUserSettings();
            }

            const userDocRef = doc(usersCollectionRef, userId);

            unsubscribeFromUserSettings = onSnapshot(userDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    currentUserSettings = { ...currentUserSettings, ...docSnap.data() };
                    userDisplayName = currentUserSettings.displayName || 'Anonymous';
                    currentUserDisplayName.textContent = userDisplayName;
                    updateUserAvatar(currentUserSettings.profilePictureUrl, userDisplayName);
                    applyUserSettings();
                    displayNameInput.value = currentUserSettings.displayName || '';
                    profilePictureUrlInput.value = currentUserSettings.profilePictureUrl || '';
                    userBioInput.value = currentUserSettings.bio || '';
                    userRoleInput.value = currentUserSettings.role || '';
                    lastActivityDisplay.textContent = currentUserSettings.lastActivity ? currentUserSettings.lastActivity.toDate().toLocaleString() : 'No activity';

                    darkModeToggle.checked = currentUserSettings.darkModeEnabled;
                    notificationsToggle.checked = currentUserSettings.notificationsEnabled;
                    boardBackgroundTypeSelect.value = currentUserSettings.boardBackgroundType || 'none';
                    boardBackgroundColorInput.value = currentUserSettings.boardBackgroundValue && currentUserSettings.boardBackgroundValue.startsWith('#') ? currentUserSettings.boardBackgroundValue : '#ffffff';
                    boardBackgroundImageInput.value = currentUserSettings.boardBackgroundValue && !currentUserSettings.boardBackgroundValue.startsWith('#') ? currentUserSettings.boardBackgroundValue : '';

                    toggleBoardBackgroundInputs();
                } else {
                    console.log("User settings doc not found, creating default.");
                    setDoc(userDocRef, currentUserSettings, { merge: true });
                }
            }, (error) => {
                console.error("Error fetching user settings:", error);
            });
        };

        /**
         * Applies the current user settings to the UI.
         */
        const applyUserSettings = () => {
            if (currentUserSettings.darkModeEnabled) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }

            notificationButton.style.display = currentUserSettings.notificationsEnabled ? 'flex' : 'none';
            if (!currentUserSettings.notificationsEnabled) {
                closeNotificationDropdown();
            }

            applyBoardBackground(currentUserSettings.boardBackgroundType, currentUserSettings.boardBackgroundValue);

            if (currentBoardId) {
                selectBoard(currentBoardId);
            }
        };

        /**
         * Applies the selected board background to the Kanban board.
         * @param {string} type - 'none', 'color', 'image', 'gradient1', 'gradient2'.
         * @param {string} value - Hex color, URL, or empty string.
         */
        const applyBoardBackground = (type, value) => {
            const appContainer = document.getElementById('app-container');
            appContainer.style.backgroundColor = '';
            appContainer.style.backgroundImage = '';
            appContainer.style.backgroundSize = '';
            appContainer.style.backgroundPosition = '';
            appContainer.style.backgroundRepeat = '';

            switch (type) {
                case 'color':
                    appContainer.style.backgroundColor = value;
                    break;
                case 'image':
                    appContainer.style.backgroundImage = `url('${value}')`;
                    appContainer.style.backgroundSize = 'cover';
                    appContainer.style.backgroundPosition = 'center';
                    appContainer.style.backgroundRepeat = 'no-repeat';
                    appContainer.style.backgroundColor = 'transparent';
                    break;
                case 'gradient1':
                    appContainer.style.backgroundImage = 'linear-gradient(to right top, #a78bfa, #8b5cf6, #6366f1, #3b82f6, #0ea5e9)';
                    appContainer.style.backgroundColor = 'transparent';
                    break;
                case 'gradient2':
                    appContainer.style.backgroundImage = 'linear-gradient(to right top, #6ee7b7, #34d399, #10b981, #059669, #047857)';
                    appContainer.style.backgroundColor = 'transparent';
                    break;
                case 'none':
                default:
                    break;
            }
        };

        /**
         * Shows/hides background input fields based on selected type.
         */
        const toggleBoardBackgroundInputs = () => {
            const selectedType = boardBackgroundTypeSelect.value;
            boardBackgroundColorGroup.classList.add('hidden');
            boardBackgroundImageGroup.classList.add('hidden');

            if (selectedType === 'color') {
                boardBackgroundColorGroup.classList.remove('hidden');
            } else if (selectedType === 'image') {
                boardBackgroundImageGroup.classList.remove('hidden');
            }
        };


        /**
         * Saves user settings to Firestore.
         */
        const saveUserSettings = async () => {
            if (!isAuthReady || !userId || !usersCollectionRef) {
                showMessage("Please log in to save settings.", 'error');
                return;
            }

            const newDisplayName = displayNameInput.value.trim();
            if (!newDisplayName) {
                showMessage("Display name cannot be empty.", 'error');
                return;
            }

            const selectedBackgroundType = boardBackgroundTypeSelect.value;
            let backgroundValue = '';

            if (selectedBackgroundType === 'color') {
                backgroundValue = boardBackgroundColorInput.value;
            } else if (selectedBackgroundType === 'image') {
                backgroundValue = boardBackgroundImageInput.value.trim();
            }

            const updatedSettings = {
                displayName: newDisplayName,
                profilePictureUrl: profilePictureUrlInput.value.trim(),
                bio: userBioInput.value.trim(),
                role: userRoleInput.value.trim(),
                darkModeEnabled: darkModeToggle.checked,
                notificationsEnabled: notificationsToggle.checked,
                boardBackgroundType: selectedBackgroundType,
                boardBackgroundValue: backgroundValue,
            };

            try {
                const userDocRef = doc(usersCollectionRef, userId);
                await updateDoc(userDocRef, updatedSettings);
                showMessage("Settings saved successfully!", 'success');
                userSettingsModal.classList.remove('show');
            } catch (error) {
                console.error("Error saving user settings:", error);
                showMessage("Failed to save settings: " + error.message, 'error');
            }
        };

        // --- LLM Integration: Generate Checklist ---
        const generateChecklist = async () => {
            if (!currentTaskId || !currentBoardId || !isAuthReady) {
                showMessage("Please select a task and board.", 'error');
                return;
            }

            const taskTitle = taskDetailTitleInput.value.trim();
            const taskDescription = taskDetailDescriptionInput.value.trim();

            if (!taskTitle && !taskDescription) {
                showMessage("Please add a task title or description to generate a checklist.", 'info');
                return;
            }

            generateChecklistButton.innerHTML = '<span class="loading-spinner"></span> Generating...';
            generateChecklistButton.disabled = true;

            const prompt = `Based on the following task details, generate a list of actionable checklist items. Provide only the checklist items as an array of strings.
            Task Title: "${taskTitle}"
            Task Description: "${taskDescription}"
            
            Example output:
            ["Item 1", "Item 2", "Item 3"]
            `;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });

            const payload = {
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "ARRAY",
                        items: { "type": "STRING" }
                    }
                }
            };

            const apiKey = ""; // Canvas will provide this at runtime
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    
                    const jsonString = result.candidates[0].content.parts[0].text;
                    const generatedItems = JSON.parse(jsonString);

                    if (Array.isArray(generatedItems) && generatedItems.length > 0) {
                        const checklistsRef = collection(db, `artifacts/${appId}/users/${userId}/boards/${currentBoardId}/tasks/${currentTaskId}/checklists`);
                        await addDoc(checklistsRef, {
                            title: "Generated Checklist",
                            items: generatedItems.map(item => ({ text: item, completed: false })),
                            createdAt: serverTimestamp()
                        });
                        showMessage("Checklist generated and added successfully!", 'success');
                        logActivity(currentTaskId, 'checklist_generated_ai', `AI generated a checklist with ${generatedItems.length} items.`);
                    } else {
                        showMessage("AI could not generate a valid checklist. Please try again.", 'info');
                    }
                } else {
                    showMessage("AI response was empty or malformed. Please try again.", 'error');
                }
            } catch (error) {
                console.error("Error generating checklist with AI:", error);
                showMessage("Failed to generate checklist with AI: " + error.message, 'error');
            } finally {
                generateChecklistButton.innerHTML = '<i class="fas fa-magic"></i> ✨ Generate Checklist';
                generateChecklistButton.disabled = false;
            }
        };

        // --- LLM Integration: Elaborate/Summarize Description ---
        const handleDescriptionElaboration = async () => {
            if (!currentTaskId || !currentBoardId || !isAuthReady) {
                showMessage("Please select a task and board.", 'error');
                return;
            }

            const taskTitle = taskDetailTitleInput.value.trim();
            let taskDescription = taskDetailDescriptionInput.value.trim();

            if (!taskTitle && !taskDescription) {
                showMessage("Please add a task title or description to elaborate/summarize the description.", 'info');
                return;
            }

            elaborateSummarizeDescriptionButton.innerHTML = '<span class="loading-spinner"></span> Processing...';
            elaborateSummarizeDescriptionButton.disabled = true;

            let prompt;
            let actionType;
            const descriptionThreshold = 100; // words

            // Simple word count approximation
            const wordCount = taskDescription.split(/\s+/).filter(word => word.length > 0).length;

            if (wordCount < descriptionThreshold) {
                actionType = 'elaborate';
                prompt = `Elaborate on the following task description, adding more detail and breaking it down into potential sub-points. Keep it concise but informative.
                Task Title: "${taskTitle}"
                Current Description: "${taskDescription}"`;
            } else {
                actionType = 'summarize';
                prompt = `Summarize the following task description concisely, highlighting the key points.
                Task Title: "${taskTitle}"
                Current Description: "${taskDescription}"`;
            }
            
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });

            const payload = {
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "text/plain" // Expecting plain text response
                }
            };

            const apiKey = ""; // Canvas will provide this at runtime
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    
                    const generatedText = result.candidates[0].content.parts[0].text;
                    taskDetailDescriptionInput.value = generatedText;
                    await updateTaskField('description', generatedText); // Save the updated description
                    showMessage(`Description ${actionType === 'elaborate' ? 'elaborated' : 'summarized'} successfully!`, 'success');
                    logActivity(currentTaskId, `description_${actionType}_ai`, `AI ${actionType === 'elaborate' ? 'elaborated' : 'summarized'} the description.`);
                } else {
                    showMessage("AI response was empty or malformed. Please try again.", 'error');
                }
            } catch (error) {
                console.error(`Error ${actionType}ing description with AI:`, error);
                showMessage(`Failed to ${actionType === 'elaborate' ? 'elaborate' : 'summarize'} description with AI: ` + error.message, 'error');
            } finally {
                elaborateSummarizeDescriptionButton.innerHTML = '<i class="fas fa-robot"></i> ✨ Elaborate/Summarize';
                elaborateSummarizeDescriptionButton.disabled = false;
            }
        };


        // --- Event Listeners and Initial Setup ---
        window.addEventListener('load', () => {
            initializeFirebase();
            resizeConfettiCanvas();
        });

        window.addEventListener('resize', () => {
            resizeConfettiCanvas();
            // Re-apply filters on resize to ensure mobile search input is used correctly
            applyFilters();
        });

        // Removed global add task listeners

        // Auth Modal Event Listeners
        showAuthModalButton.addEventListener('click', () => {
            authModal.classList.add('show');
            authEmailInput.value = '';
            authPasswordInput.value = '';
            clearAuthError();
            toggleAuthMode();
        });
        modalCloseButton.addEventListener('click', () => {
            authModal.classList.remove('show');
        });
        emailAuthButton.addEventListener('click', handleEmailAuth);
        forgotPasswordLink.addEventListener('click', (e) => {
            e.preventDefault();
            handleForgotPassword();
        });
        toggleAuthModeLink.addEventListener('click', toggleAuthMode);
        googleSigninButton.addEventListener('click', handleGoogleLogin);
        anonymousLoginButton.addEventListener('click', handleAnonymousLogin);
        logoutButton.addEventListener('click', handleLogout);

        // Board Management Event Listeners
        addBoardButton.addEventListener('click', () => {
            createBoardModal.classList.add('show');
            newBoardNameInput.value = '';
        });
        createBoardModalCloseButton.addEventListener('click', () => {
            createBoardModal.classList.remove('show');
        });
        createBoardSubmitButton.addEventListener('click', handleCreateBoard);
        newBoardNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleCreateBoard();
            }
        });
        boardSelector.addEventListener('change', (e) => {
            selectBoard(e.target.value);
        });
        renameBoardButton.addEventListener('click', () => {
            if (currentBoardId) {
                renameBoardNameInput.value = boardSelector.options[boardSelector.selectedIndex].textContent;
                renameBoardModal.classList.add('show');
            } else {
                showMessage("Please select a board to rename.", 'error');
            }
        });
        renameBoardModalCloseButton.addEventListener('click', () => {
            renameBoardModal.classList.remove('show');
        });
        renameBoardSubmitButton.addEventListener('click', handleRenameBoard);
        renameBoardNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleRenameBoard();
            }
        });
        deleteBoardButton.addEventListener('click', handleDeleteBoard);
        shareBoardButton.addEventListener('click', handleShareBoard);
        shareBoardModalCloseButton.addEventListener('click', () => shareBoardModal.classList.remove('show'));
        copyShareLinkButton.addEventListener('click', copyShareLink);

        // Column Management Event Listeners
        addColumnButton.addEventListener('click', () => {
            if (!currentBoardId) {
                showMessage("Please select a board to add a column to.", 'error');
                return;
            }
            addColumnModal.classList.add('show');
            newColumnNameInput.value = '';
        });
        addColumnModalCloseButton.addEventListener('click', () => addColumnModal.classList.remove('show'));
        addColumnSubmitButton.addEventListener('click', handleAddColumn);
        newColumnNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleAddColumn();
            }
        });

        renameColumnButton.addEventListener('click', () => {
            if (!currentBoardId) {
                showMessage("Please select a board to rename a column in.", 'error');
                return;
            }
            populateColumnSelects();
            renameColumnModal.classList.add('show');
        });
        renameColumnModalCloseButton.addEventListener('click', () => renameColumnModal.classList.remove('show'));
        renameColumnSubmitButton.addEventListener('click', handleRenameColumn);
        selectColumnToRename.addEventListener('change', (e) => {
            const selectedColumn = currentBoardColumns.find(col => col.id === e.target.value);
            if (selectedColumn) {
                renameColumnNameInput.value = selectedColumn.name;
            }
        });
        renameColumnNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleRenameColumn();
            }
        });

        deleteColumnButton.addEventListener('click', () => {
            if (!currentBoardId) {
                showMessage("Please select a board to delete a column from.", 'error');
                return;
            }
            populateColumnSelects();
            deleteColumnModal.classList.add('show');
        });
        deleteColumnModalCloseButton.addEventListener('click', () => deleteColumnModal.classList.remove('show'));
        deleteColumnSubmitButton.addEventListener('click', handleDeleteColumn);

        // Add column placeholder click listener
        addColumnPlaceholder.addEventListener('click', () => {
            if (!currentBoardId) {
                showMessage("Please select a board to add a column to.", 'error');
                return;
            }
            addColumnModal.classList.add('show');
            newColumnNameInput.value = '';
        });


        // Task Detail Modal Event Listeners
        taskDetailModalCloseButton.addEventListener('click', closeTaskDetailModal);
        taskDetailTitleInput.addEventListener('change', (e) => updateTaskField('text', e.target.value));
        taskDetailDescriptionInput.addEventListener('change', (e) => updateTaskField('description', e.target.value));
        elaborateSummarizeDescriptionButton.addEventListener('click', handleDescriptionElaboration); // New LLM button listener
        taskDetailDueDateInput.addEventListener('change', (e) => updateTaskField('dueDate', e.target.value));
        taskDetailAssignedToInput.addEventListener('change', (e) => updateTaskField('assignedTo', e.target.value));
        taskDetailPrioritySelect.addEventListener('change', (e) => updateTaskField('priority', e.target.value));
        addChecklistButton.addEventListener('click', handleAddChecklist);
        generateChecklistButton.addEventListener('click', generateChecklist); // Event listener for the new LLM button
        addCommentButton.addEventListener('click', handleAddComment);
        newCommentInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleAddComment();
            }
        });

        // Filter & Search Event Listeners
        taskSearchInput.addEventListener('input', applyFilters); // Desktop search
        taskSearchInputMobile.addEventListener('input', applyFilters); // Mobile search
        filterStatusSelect.addEventListener('change', applyFilters);
        filterAssignedToInput.addEventListener('input', applyFilters);
        filterDueDateSelect.addEventListener('change', applyFilters);
        filterPrioritySelect.addEventListener('change', applyFilters);

        // Notification Event Listeners
        notificationButton.addEventListener('click', toggleNotificationDropdown);
        markAllReadButton.addEventListener('click', markAllNotificationsAsRead);

        // Close dropdown when clicking outside
        document.addEventListener('click', (event) => {
            if (!notificationDropdown.contains(event.target) && !notificationButton.contains(event.target)) {
                closeNotificationDropdown();
            }
        });


        // User Settings Event Listeners
        userSettingsButton.addEventListener('click', () => {
            displayNameInput.value = currentUserSettings.displayName || '';
            profilePictureUrlInput.value = currentUserSettings.profilePictureUrl || '';
            userBioInput.value = currentUserSettings.bio || '';
            userRoleInput.value = currentUserSettings.role || '';
            lastActivityDisplay.textContent = currentUserSettings.lastActivity ? currentUserSettings.lastActivity.toDate().toLocaleString() : 'No activity';

            darkModeToggle.checked = currentUserSettings.darkModeEnabled;
            notificationsToggle.checked = currentUserSettings.notificationsEnabled;
            boardBackgroundTypeSelect.value = currentUserSettings.boardBackgroundType || 'none';
            boardBackgroundColorInput.value = currentUserSettings.boardBackgroundValue && currentUserSettings.boardBackgroundValue.startsWith('#') ? currentUserSettings.boardBackgroundValue : '#ffffff';
            boardBackgroundImageInput.value = currentUserSettings.boardBackgroundValue && !currentUserSettings.boardBackgroundValue.startsWith('#') ? currentUserSettings.boardBackgroundValue : '';

            updateUserAvatar(profilePictureUrlInput.value, displayNameInput.value);

            toggleBoardBackgroundInputs();
            userSettingsModal.classList.add('show');
        });
        userSettingsModalCloseButton.addEventListener('click', () => {
            userSettingsModal.classList.remove('show');
        });
        saveUserSettingsButton.addEventListener('click', saveUserSettings);

        profilePictureUrlInput.addEventListener('input', () => {
            updateUserAvatar(profilePictureUrlInput.value, displayNameInput.value);
        });
        displayNameInput.addEventListener('input', () => {
            updateUserAvatar(profilePictureUrlInput.value, displayNameInput.value);
        });

        darkModeToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        boardBackgroundTypeSelect.addEventListener('change', toggleBoardBackgroundInputs);


        // Custom Confirmation Modal Event Listeners
        confirmYesButton.addEventListener('click', () => {
            if (confirmationCallback) {
                confirmationCallback(true);
            }
            confirmationModal.classList.remove('show');
        });

        confirmNoButton.addEventListener('click', () => {
            if (confirmationCallback) {
                confirmationCallback(false);
            }
            confirmationModal.classList.remove('show');
        });
    </script>
</body>
</html>


